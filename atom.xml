<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jenkinsxu.github.io</id>
    <title>Jenkins&apos; Secret Base</title>
    <updated>2020-01-18T18:30:59.218Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jenkinsxu.github.io"/>
    <link rel="self" href="https://jenkinsxu.github.io/atom.xml"/>
    <subtitle>ｄ(･∀･*)♪ﾟYou found my secret base! 

（更多关于我就在 About 标签中）</subtitle>
    <logo>https://jenkinsxu.github.io/images/avatar.png</logo>
    <icon>https://jenkinsxu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Jenkins&apos; Secret Base</rights>
    <entry>
        <title type="html"><![CDATA[Algorithms - Week 2]]></title>
        <id>https://jenkinsxu.github.io/post/algorithms-week-2</id>
        <link href="https://jenkinsxu.github.io/post/algorithms-week-2">
        </link>
        <updated>2020-01-18T02:30:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="modular-division">Modular Division</h2>
<ul>
<li>Dividing by a != 0 is the same as multiplying by a^(-1) = 1 / a (the inverse of a). Here we assume rational numbers.</li>
<li>In modular arithmetic:
<ul>
<li>“x is said to be the multiplicative inverse of a modulo N if a*x ≡ 1 (mod N)”</li>
</ul>
</li>
<li>We call such an x the inverse of a and denote it a^(-1)
<ul>
<li>Now modular division become the problem of computing x = a^(-1) , given a and N<br>
<strong>Example:</strong><br>
<strong>Q:</strong> What is 11^(-1) mod 25 (i.e. The inverse of 11 mod 25)<br>
⇒ we use the extended Euclidian Algorithm For gcd (25, 11)<br>
⇒ 15 * 25 - 34 * 11 = 1, Now reduce both sides mod 25<br>
⇒ 0 - 34 * 11 ≤ 1 (mod 25)<br>
16 * 11≡1<br>
⇒ 16 is the inverse of 11 (mod 25)<br>
<strong>Q:</strong> Does the inverse a^(-1) always exist?<br>
<strong>A:</strong> No, only when gcd (a, N) = 1, i.e. a and N are relative prime.<br>
We know that ax + Ny = 1 (via extended Euclidian Algorithm) &lt;⇒ ax ≡ 1 (mod N) ⇒ x is a’s inverse mod N. However, if gcd (a, N) &gt; 1, then no inverse of a mod N exists. (convince yourself that this is true, page 23 is helpful)</li>
</ul>
</li>
</ul>
<h3 id="modular-division-theorem">Modular Division Theorem</h3>
<p>For any a mod N, a has a multiplicative inverse mod N &lt;⇒ gcd (a, N) = 1.<br>
When this inverse exists, it can be computed in O(n³) time by running the extended Euclid algorithm for gcd(a, N) where n = # of bits for N.</p>
<h3 id="primality-testing">Primality Testing</h3>
<p><strong>Q:</strong> Can we decide whether integer x is prime without factoring?<br>
<strong>A:</strong> Yes, to some extend.<br>
<strong>Goal:</strong>	input N<br>
output yes (if N is prime)<br>
output no (if N is composite)<br>
With a minuscule rate of error.<br>
<strong>Tools Fermat’s little theorem:</strong><br>
If p is prime, then ∀a: 1 ≤ a ≤ p: a^(p-1) ≡ 1 (mod p) (<strong>HW</strong>: Proof - textbook)</p>
<p><strong>Example:</strong><br>
p = 7 (p is prime)<br>
1^6 ≡ 2^6 ≡ 3^6 ≡ 4^6 ≡ 5^6 ≡ 1 mod 7</p>
<p>p = 8 (p is composite)<br>
2^(p-1) = 2^4 = 128 and 128 !≡ 1 mod 8</p>
<p>However, Fermat’s little theorem is not an “if and only if” statement. Therefore some composite numbers will pass it!<br>
341 = 11 * 13  is not prime, yet 2^340 ≡ mod 341, so 341 passes the Fermat’s test, but is composite.<br>
Here 341 is called a <strong>Fermat Pseudoprime</strong> and a = 2 is called a <strong>Fermat Liar</strong>.</p>
<p><strong>Hope:</strong> For composite N, most values of a will fail the test.<br>
⇒ simple algorithm for testing primality</p>
<p>…</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Algorithms - Week 1]]></title>
        <id>https://jenkinsxu.github.io/post/algorithms-week-1</id>
        <link href="https://jenkinsxu.github.io/post/algorithms-week-1">
        </link>
        <updated>2020-01-14T11:11:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="fib">fib()</h1>
<h3 id="the-formula">The formula</h3>
<h3 id="facts">Facts</h3>
<ul>
<li>Grow as fast as 2^n</li>
<li>fib(100) is 21 digits long</li>
<li>In general T(n) = 2^(0.694n)</li>
</ul>
<p><strong>Q: What is the precise value of F100 or F200</strong><br>
A exponential algorithm:</p>
<pre><code class="language-python">func fib(n):
	if n = 0: return 0
	if n = 1: return 1
	return fib(n - 1) + fib(n - 2)
</code></pre>
<h3 id="any-algorithm-implies-3-questions">Any algorithm implies 3 questions</h3>
<ol>
<li>Is it correct?</li>
<li>How much time does it take as a function of input size n?</li>
<li>Can we do better?</li>
</ol>
<ul>
<li>Often, space is an important consideration too.</li>
</ul>
<h3 id="answers">Answers</h3>
<ol>
<li>Yes, by definition</li>
<li>Let T(n) be the # of steps needed to compute fib(n)
<ul>
<li>T(n) ≤ 2 for n ≤ 1</li>
<li>T(n) = T(n-1) + T(n-2) + 3 for n &gt; 1<br>
**Observation:**T(n) ≥ F(n)<br>
<strong>Conclusion:</strong><br>
The running time grows as fast as the fibonacci numbers.<br>
T(n) is exponential in n, so very impractical (except for very small n's)<br>
<strong>Q:</strong> How bad?<br>
<strong>A:</strong><br>
T(200) ≥ F100 ≥ 2^138 elementary computing steps.<br>
With 40 trillion operations per seconds (NEC Earth simulator):</li>
<li>fib(200) taken about 2 ^ 92 seconds</li>
<li>Longer than the remaining life of our sun<br>
Even Moore's Law doesn't help.</li>
<li>Computers get 1.6 times faster every year or twice as fast every 18 months.</li>
<li>fib(n) taken roughly 2^0.694n (or 1.6^n)
<ul>
<li>It takes 1.6 times longer to compute Fn+1 than Fn</li>
<li>If we can compute F100 with this years technology, then we can compute F101 with next year's technology. (One more Fibonacci number per year. )</li>
</ul>
</li>
</ul>
</li>
<li>A polynomial algorithm<br>
<strong>Q:</strong> Why is fib(n) so slow?<br>
<strong>A:</strong>  repeated calls<br>
<strong>More sensible approach:</strong> store intermediate results (a form of dynamic programming)</li>
</ol>
<pre><code class="language-swift">func fib(n) {
	if n = 0 {
		return 0
	}
	f = [0, 1]
	for i in 2...n {
		f.append(f[i-1] + f[i-2])	
	}
	return f[n]
}
</code></pre>
<ul>
<li>Correct by definition</li>
<li>Inner loop gets executed n-1 times (one addition)
<ul>
<li>fib(n) is linear in n</li>
<li>we are now down from exponential to linear time</li>
<li>One outstanding issue: fib(n) has to add increasingly larger integers
<ul>
<li>issues around precision or time</li>
<li>it takes more time to add F199 and F200 than e.g. F3 and F4
<ul>
<li>fib(n) roughly performed Fn additions -&gt; # of basic steps is roughly proportional to n*Fn (still exponential)</li>
</ul>
</li>
</ul>
</li>
<li>
<h1 id="of-basic-steps-is-roughly-proportional-to-n2-still-polynomial-hw-why-bits-level">of basic steps is roughly proportional to <strong>n^2</strong> (still polynomial) <strong>[HW: Why? - bits level]</strong></h1>
</li>
</ul>
</li>
</ul>
<h1 id="the-big-o-notation">The Big-O Notation</h1>
<ul>
<li>
<p>Need to be precise, but not overly detailed</p>
</li>
<li>
<p>Want to be <strong>machine and architecture independant</strong></p>
</li>
<li>
<p>Further simplification</p>
</li>
<li>
<p>can be viewed as the analog of the relation ⊆</p>
</li>
<li>
<p>we can also define the analogs of ≥ and = as follows</p>
<ul>
<li>f = Ω(g) means g = O(f)</li>
<li>f = Θ(g) means f = O(g) and f = Ω(g)</li>
</ul>
</li>
</ul>
<h1 id="algorithms-with-numbers">Algorithms with numbers</h1>
<h2 id="factoring">Factoring</h2>
<p>Express N as product of its prime factors.</p>
<ul>
<li>Factoring is hard. Exponential in he number of bits of N.</li>
</ul>
<h2 id="primality">Primality</h2>
<p>Is N a prime?</p>
<ul>
<li>Primality testing is very easy!</li>
</ul>
<p>As we shall see, the above 2 problems lie at the heart of <strong>secure encrypted communication</strong>.</p>
<p>First things first: Need for algorithms for basic arithmetic.</p>
<h3 id="basic-grade-school-addition">Basic (grade school) addition</h3>
<ul>
<li>Works because the sum of any 3 single digit number is at most 2 digits long (this holds for all bases b ≥ 2)
<ul>
<li>Example:</li>
</ul>
</li>
</ul>
<pre><code>	110101 
+	100011
---------
1 011000
</code></pre>
<p><strong>Q:</strong> How fast is this?<br>
<strong>A:</strong> 2n bit number can be added in n + 1 steps, so about c0 + c1*n ⇒ O(n).<br>
<strong>Q:</strong> Can we do better?<br>
<strong>A:</strong> At the minimum we must read 2 n-bit numbers and write down the answer. Even that requires n steps. ⇒ it is <strong>optimal</strong>. (Up to multiplicative constants c0 and c1)</p>
<h3 id="multiplication">Multiplication</h3>
<ul>
<li>The grade school algorithm</li>
<li>The Al-Khwarizmi Multiplication</li>
</ul>
<pre><code>11*13 table
div2, floor()		*2
11					13
5					26
2					52 (strike out)
1					104
</code></pre>
<pre><code>* strike out all rows where x is even
* then add column 2
</code></pre>
<p><strong>Q:</strong> How does this relate to the binary grade school multiplication algorithm?<br>
<strong>A:</strong> The second algorithm is essentially the same as the binary multiplication. We are adding multiples of 13 by powers of 2 as before.<br>
As before:</p>
<pre><code>2^0 * 13 = 13
2^1 * 13 = 26
2^2 * 13 = 104	∑ = 143
// See text for a third alternative of multiplication
// All 3 versions of multiplication require O(n²) if n = # of bits. 
// We can do better! 
</code></pre>
<h3 id="division">Division</h3>
<p>To divide integer x by integer y ≠ 0 means to fine integer q and r &lt; y such that x = q(quotient) * y + r(remainder)</p>
<ul>
<li>Standard division (see Fig. 1.2. in text) takes quadratic time.</li>
</ul>
<h1 id="modular-arithmetic">Modular Arithmetic</h1>
<p>Modular arithmetic is a system for dealing with restricted ranges of integers.<br>
<code>x modulo N -&gt; remainder when x is divided by N</code><br>
Ex. 	17 modulo 4 = 1<br>
21 modulo 4 = 1<br>
We say that 17 and 21 are congruent modulo 4. Notation:</p>
<pre><code>a ≡ b (mod n)
Clock with 60 minutes: -1 ≡ 59 (mod 60)
</code></pre>
<ul>
<li>Modular arithmetic can be thought of as limiting integers to a specific range of [0, 1, ... , N-1] with &quot;wrap-around&quot;.</li>
<li>Another interpretation is that it deals with all integer, but divides them into N equivalence classes.</li>
</ul>
<pre><code>	...	-9	-6	-3	[0]	3	6	...
{	...	-8	-5	-2	[1]	4	7	...	} 3 equivalent classes mod 3
	...	-7	-4	-1	[2]	5	8	...
</code></pre>
<h3 id="laws-in-modular-arithmetic">Laws in Modular Arithmetic</h3>
<ul>
<li>Substitution Law<br>
If 		x ≡ x' (mod N) and y ≡ y' (mod N)<br>
then:	x + y ≡ x' + y' (mod N) and<br>
x * y ≡ x' * y' (mod N)</li>
<li>Commutative, Associative, Distributive Laws (etc.) also hold (<strong>HW</strong>)</li>
<li>Can do reduction during calcualtion<br>
2^345 ≡ (2<sup>5)</sup>69 ≡ 32^69 ≡ 1^69 ≡ 1	(mod 31)  31 = (2^5 - 1)<br>
(because 31≡ 1 mod 31)</li>
</ul>
<h3 id="addition-mod-n">Addition (mod N)</h3>
<p>x + y (mod N)<br>
x and y are in the range 0 to N-1 ⇒ x + y ∈ [0, ... , 2(N-1)]<br>
if x + y &gt; N-1, simply <strong>subtract N</strong> to reduce mod N<br>
⇒ 1 addition, possibly 1 subtraction of numbers ≤ 2N<br>
⇒ Run time is O(n), where n = ceil(logN) (# of bits)</p>
<h3 id="multiplication-mod-n">Multiplication (mod N)</h3>
<ul>
<li>product is ≤ (N-1)², at most 2n bits -&gt; since log(N-1)² = 2*log(N-1) ≤ 2n
<ul>
<li>regular multiplication: x*y -&gt; O(n²)</li>
<li>reduce mod N</li>
</ul>
</li>
<li>Use division algorithm O(n²) to get the remainder<br>
⇒ O(n²) for modular multiplication</li>
</ul>
<h3 id="division-2">Division</h3>
<ul>
<li>Not quite so straight forward</li>
<li>Can be managed in O(n³) time
<ul>
<li>This is more expensive than regular integer division that was O(n²)</li>
</ul>
</li>
</ul>
<h3 id="modular-exponentiation">Modular Exponentiation</h3>
<p>Goal: Build a crypto-system</p>
<ul>
<li>We need to compute x^y mod N, where x, y and N are several 100 bits long.</li>
<li>x^y is huge even if x and y are only 20-bit numbers.<br>
⇒ x^y is at least (2<sup>19)</sup>(2^19) or about 10,000,000 bits long.</li>
</ul>
<hr>
<p>We could just repeatedly multiply by x modulo y</p>
<pre><code>x		mod N
x²		mod N
x³		mod N
...
x^y	mod N 
</code></pre>
<p>All numbers are &lt; N, but we need to perform y-1 multiplications!<br>
If y has 500 bits ⇒ y - 1 ≈ 2^500 multiplications!<br>
⇒ clearly exponential in the size of y.</p>
<p><strong>Q:</strong> Can we do better?<br>
<strong>A:</strong> Yes! Square repeatedly modulo N</p>
<pre><code>	 x 	mod N 
	 x²	mod N
	 ...
	 x^2^( ceil( log y ) ) mod N
</code></pre>
<ul>
<li>Each takes O(log²N) time
<ul>
<li>numbers are &lt; N</li>
<li>have &lt; logN bits<br>
⇒ now only log y multiplications</li>
</ul>
</li>
<li>Now, we have all x<sup>(2</sup>i)  (1 ≤ i ≤ ceil( log y ) )</li>
<li>To determine x^y mod N proceed as follows:</li>
</ul>
<pre><code>x^25 ≡ x^11001 	≡ x^10000 * x^1000 * x^1
					≡ x^16 * x^8 * x 	mod N (look up in table)
</code></pre>
<hr>
<p><strong>Alternate Formulation</strong><br>
Recursive Algorithm (Fig. 1.4)</p>
<pre><code>x^y
	= (x ^ ceil(y / 2) ) ² if y is even
	= x * (x ^ ( x^(y / 2) ) ) if y is odd
execute this mod N. 
</code></pre>
<ul>
<li>Recursive multiplication used repeated doubling</li>
<li>Recursive exponentiation uses repeated squaring<br>
⇒ n recursive calls (O(n)), multiply n-bit numbers (O(n²))<br>
⇒ O(n³) for modular exponentiation.</li>
</ul>
<h2 id="division-and-mod-n-need-gcd-and-euclids-algorithm">Division and mod N - Need GCD and Euclids Algorithm</h2>
<ul>
<li>gcd(a, b) is the largest integer d that divides both a and b</li>
<li>One approach to compute gcd: factor a and b, then multiply together their common factors:<br>
<strong>Example:</strong></li>
</ul>
<pre><code>1035	= 3² * 5 * 23 
759	= 3 * 11 * 23
Common factors: 3 and 23
⇒ 3 * 32 = 69 is the gcd of 1035 and 759
</code></pre>
<p><strong>But:</strong> Factoring is hard!</p>
<p><strong>Solution:</strong> Euclid's Algorithm<br>
* Based on the following rule: If x and y are positive integers with x ≥ y, then <strong>gcd(x, y)  = gcd(x mod y, y)</strong><br>
<strong>Proof:</strong> Enough to show the simpler rule gcd(x, y)  = gcd(x-y, y).<br>
* Any integer that divides both x and y must also divide x-y, so gcd(x, y) ≤ gcd(x-y, y).<br>
* Likewise, any integer that divides both x-y and y, must  also divide x, so gcd(x-y, y) ≤ gcd(x, y)<br>
⇒ gcd(x, y) = gcd(x-y, y)</p>
<hr>
<p><strong>Euclid's algorithm for finding gcd(a, b)</strong><br>
function Euclid(a, b)<br>
Input: a, b ∈ H+ with a ≥ b ≥ 0<br>
Output: 		gcd(a, b)<br>
if b = 0: return a mod b<br>
Time: After any 2 consecutive rounds, both argument a and b, are the the vast least halved in value, i, e. t their length decreases by at least one bit.<br>
* the base case can be reached within 2n recursive call<br>
* Each call involves O(n²) division<br>
* total time is O(n³)<br>
<strong>HW:</strong> Think about the details. See P.21 for more info.</p>
<hr>
<p><strong>Extension to Euclid's Algorithm</strong><br>
* The gcd(a, b) is the <strong>smallest</strong> positive integer that can be written s a linear combination of a and b.<br>
⇒ d = gcd(a, b) ≡ ax+ by (linear combination) for some integer x and y. (And d must be <strong>minimal</strong>.)</p>
<p>Textbook uses a slightly different approach.<br>
<strong>Q:</strong> What is different?<br>
<strong>A:</strong> We can extend the Euclidian Algorithm to compute the coefficients for the linear combination.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java Programming: Week 1-2]]></title>
        <id>https://jenkinsxu.github.io/post/java-programming-week-1-2</id>
        <link href="https://jenkinsxu.github.io/post/java-programming-week-1-2">
        </link>
        <updated>2020-01-13T20:22:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="basic-java">Basic Java</h2>
<hr>
<h3 id="classes-in-java">Classes in Java</h3>
<pre><code class="language-java">// Can have nested classes, but no more than one full class in  a file
public class HelloWorld {
	public static void main(String[] arug) {
		// static: excuse it without instantiating the object
		System.out.println(&quot;Hello, world.&quot;);
	}
	// no linking errors when multiple main()'s in different classes
}
</code></pre>
<h3 id="shortcuts">Shortcuts</h3>
<ul>
<li>To run a program for the first time: <strong>Control-Option-R</strong></li>
<li>To run a program the second or more time: <strong>Control-R</strong></li>
<li>Refactoring: <strong>Control-Alt-V</strong></li>
<li>Quick Fixes: <strong>Option-Enter</strong></li>
<li>To check required arguments: <strong>Control-P</strong></li>
<li>Generate a constructor_setter_getter: <strong>Alt-Insert</strong></li>
<li>Gets to where a class is defined: <strong>Option-Click</strong></li>
<li>Assisted correction: <strong>Alt-Enter</strong></li>
<li>Duplicate line: <strong>Control-D</strong></li>
<li>Move a line: <strong>Control-Shift-Up/Down</strong></li>
<li>System.out.println(): <strong>“sout”-Enter</strong></li>
</ul>
<h3 id="the-math-class-static">The Math class (static)</h3>
<ul>
<li>.sqrt()</li>
<li>.ceil()</li>
<li>.pow()</li>
<li>.PI</li>
</ul>
<h3 id="garbage-collection-and-multiple-object-reference">Garbage Collection and Multiple Object Reference</h3>
<p>An object is said to be eligible for GC (garbage collection) iff it is <strong>unreachable</strong>. An object is said to be unreachable iff it doesn’t contain any reference to it.</p>
<pre><code class="language-java">Integer i = new Integer(4);
// the new Integer object is reachable  via the reference in 'i' 
i = null;
// the Integer object is no longer reachable. 

GreetingsSelf phoneMsg = new GreetingsSelf(&quot;Einstein&quot;); 
//Use the new keyword when an object is being explicitly created for the first time. Java has only dynamic objects. If the new keyword is not used, it will copy a reference to the same object. 
GreetingsSelf emailMsg = phoneMsg;
emailMsg.setName(&quot;Albert&quot;); // Both are set to &quot;Albert&quot;
</code></pre>
<h3 id="automatic-type-promotion">Automatic Type Promotion</h3>
<pre><code class="language-java">class Test 
{ 
    public static void main(String[] args) 
    { 
        int i = 100;
        // automatic type conversion 
        long l = i;  
        // automatic type conversion 
        float f = l;  
        System.out.println(&quot;Int value &quot;+i); // 100
        System.out.println(&quot;Long value &quot;+l); // 100
        System.out.println(&quot;Float value &quot;+f); // 100.0
    } 
} 
</code></pre>
<p><code>(double)height / width</code></p>
<h3 id="type-casting">Type Casting</h3>
<p><code>(double)weightInG</code></p>
<h3 id="lists">Lists</h3>
<pre><code class="language-java">// null reference
ArrayList&lt;Door&gt; doors1;
// Type inference
ArrayList&lt;Door&gt; doors2 = new ArrayList&lt;&gt;();
// Using polymorphism to simplify code
List&lt;Door&gt; doors = ArrayList&lt;&gt;(); 

// appending
doors.add(new Door(true, 1000));
heavyDoors.add(door); // taking your reference to one door (the same object)
// indexing
doors.get(0);
doors.get(doors.size() - 1);
// if the door is empty
doors.isEmpty();
</code></pre>
<h3 id="interface-empty-bodies">Interface (&quot;empty bodies&quot;)</h3>
<pre><code class="language-java">interface Animal {
	public void animalSound();
	public void sleep();
}

class Pig implements Animal {
	public void animalSound() {
		System.out.println(&quot;wee wee&quot;);
	}
	public static void sleep() {
		System.out.println(&quot;Zzz&quot;);
	}
}
</code></pre>
<h3 id="generic-classes">Generic Classes</h3>
<pre><code class="language-java">public class GenericsType&lt;T&gt; {

	private T t;
	
	public T get(){
		return this.t;
	}
	
	public void set(T t1){
		this.t=t1;
	}
	
	public static void main(String args[]){
	}
}
</code></pre>
<h3 id="enhanced-for-loop">Enhanced for loop</h3>
<pre><code class="language-java">// implement the Iterable&lt;&gt; interface
public class DoorManager implements Iterable&lt;Door&gt; {
	//Type inference
	private List&lt;Door&gt; doors = new ArrayList&lt;&gt;(); 

	public void add(Door door){
		doors.add(door);
	}
	// Class 'DoorManager' must either be declared abstract or implemented abstract method 'iterator()' in 'Iterable'
	public iterator&lt;Door&gt; iterator(){
		return this.doors.iterator();
		// Lists of Door return iterator of Door
	}
}

// Prerequisite: iterable 
for (Door door : doors) {
	System.out.println(&quot;Door = &quot; + door);
}
</code></pre>
<h3 id="dependency-injection">Dependency Injection</h3>
<p>Transferring the task of creating the object to someone else and directly using the dependency is called <strong>dependency injection</strong>.</p>
<p>Ideally Java classes should be as independent as possible from other Java classes. This <strong>increases the possibility of reusing</strong> these classes and to be able to <strong>test them independently from other classes</strong>.</p>
<p>If the Java class <strong>creates an instance of another class via the new operator</strong>, it cannot be used (and tested) independently from this class and this is called a <strong>hard dependency</strong>.</p>
<pre><code class="language-java">public class MyClass {

    private Logger logger;

    public MyClass(Logger logger) {
        this.logger = logger;
        // write an info log message
        logger.info(&quot;This is a log message.&quot;)
    }
}
</code></pre>
<p>Three Types of Dependency Injection</p>
<ol>
<li>Constructor Injection</li>
<li>Setter Injection</li>
<li>Interface Injection</li>
</ol>
<h3 id="user-input">User Input</h3>
<pre><code class="language-java">import java.util.Scanner;  // Import the Scanner class

class MyClass {
  public static void main(String[] args) {
    Scanner myObj = new Scanner(System.in);  // Create a Scanner object
    System.out.println(&quot;Enter username&quot;);

    String userName = myObj.nextLine();  // Read user input
    System.out.println(&quot;Username is: &quot; + userName);  // Output user input
  }
}

</code></pre>
<h3 id="switch-statement">Switch Statement</h3>
<pre><code class="language-java">switch(choice) {
	case 1:
		System.out.println(&quot;You entered a one!&quot;);
		System.out.println(&quot;Thank you!&quot;);
	case 2:
		System.out.println(&quot;You entered a two!&quot;);
		System.out.println(&quot;Amazing!&quot;);
	case 3:
		System.out.println(&quot;You entered a three!&quot;);
		System.out.println(&quot;Good!&quot;);
	default:
		System.out.println(&quot;You entered a number!&quot;);
		System.out.println(&quot;lol!&quot;);
}
</code></pre>
<hr>
<h2 id="the-good-coding-style">The Good Coding Style</h2>
<h3 id="the-one-name-principle">The One Name Principle</h3>
<p>Use the <strong>this</strong> keyword to reference the current object for clarity. Java will do auto dereference when an object is not needed.<br>
Name field and constructor parameters the same.</p>
<h3 id="classes-and-visibility">Classes and Visibility</h3>
<ul>
<li>All <strong>fields</strong> (instance data) are set to <strong>private</strong>. Public methods can call private mothods.</li>
<li>If you want something to be unchangeable, you may provide no setters to prevent invalid data.
<ul>
<li>Easier for maintainance</li>
</ul>
</li>
<li>Using constant when applicable (the <strong>final</strong> keyword, UPPERCASE)
<ul>
<li>Final Variable -&gt; To create constant variables</li>
<li>Final Methods -&gt; Prevent Method Overriding</li>
<li>Final Classes -&gt; Prevent Inheritance</li>
</ul>
</li>
<li>Use the <strong>static</strong> keyword <strong>only when sharing is intended</strong></li>
<li><code>/src/main/java/…</code></li>
<li>Return a string instead of printing it to console directly.</li>
<li>Primitive Types are not objects. Everything else is an object reference.</li>
</ul>
<h3 id="type-conversion">Type Conversion</h3>
<ol>
<li>Type Promotion: Converting from a smaller type to a larger one.<br>
<code>double weight = 200;</code></li>
<li>Type Demotion</li>
</ol>
<pre><code class="language-java">int height = (int) 10.99;
float length = float 12.0; // by default it uses double
</code></pre>
<ol start="3">
<li>Constants<br>
<code>final int MAX_LENGTH = 100;</code></li>
</ol>
<h3 id="javadoc-documentation">JavaDoc (Documentation)</h3>
<pre><code class="language-java">/**
	* @author
	* @param a Length of the first side; must be &gt;= 0. 
	*/
</code></pre>
<p>Use it for classes (the purpose of a class etc.) and sometimes for API methods. Don't comment functions / methods, instead, use better naming.</p>
<h3 id="package-model-view">Package &amp; Model-View</h3>
<ul>
<li>Creat a package: <strong>src / main / java -&gt; new -&gt; Package</strong></li>
<li>Example naming: <code>ca.doordemo.model</code></li>
<li>Package is a group of classes that's related to each other. On top of each class within a package, there will be a statement similar to <code>package ca.doordemo.model</code> claiming that the class belongs to which package.</li>
<li>Do not use any System.out.println() in model to increase reusability. (On some platform System.out.println() has no meaning. )</li>
</ul>
<pre><code class="language-java">import ca.doordemo.model.DoorManager;
import ca.doordemo.ui.DoorTextUI;

public class Main {
	// Create model
	DoorManager manager = new DoorManager();
	
	// Create UI
	DoorTextUI ui = new DoorTextUI(Manager);

	// Launch
	ui.show();
}
</code></pre>
<hr>
<h3 id="others">Others</h3>
<ul>
<li><code>boolean</code>is set to false by default.</li>
<li><strong>?</strong>: Providing constructors will delete the default constructor set up by Java</li>
<li><strong>Concatenating</strong> a string and an instance will automatically call the .toString() method.</li>
<li>Everything in Java is a reference, every class is a subclass of the Object class.</li>
<li>println -&gt; prints with <strong>linefeed</strong></li>
<li>char -&gt; Unicode</li>
<li>boolean has only true or false to prevent the &quot;==&quot; mistyping issues.</li>
<li>Divide by 0.0 -&gt; Infinity</li>
</ul>
<hr>
<h2 id="static-exceptions-debugging">Static, Exceptions &amp; Debugging</h2>
<h3 id="static">Static</h3>
<ul>
<li>Static methods / class methods</li>
<li>Static field / class data
<ul>
<li>Often used for constant <code>public static final int DAYS_WEEK = 7</code></li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class StaticFun {
	public static final int TARGET_NUM_HATS = 10;
	private static int countNumMade = 0;
	private int favNum = 0;

	public static void main(String[] args) {
		changeFavNum(42); // ⚠️ non-static function misused
		displayInfo(); 
		favNum = 10; // ⚠️ non-static field
		countNumMade = 9;
	}
	private void changeFavNum(int i) {
		favNum = TARGET_NUM_HATS + i;
		displayInfo();
	}
	private static void displayInfo() {
		System.out.println(&quot;TARGET_NUM_HATS: &quot; + TARGET_NUM_HATS);
		System.out.println(&quot;countNumMade: &quot; + countNumMade);
		System.out.println(&quot;favNum: &quot; + favNum);
	}
}
</code></pre>
<h3 id="exceptions">Exceptions</h3>
<p>Catch the error so that we don't have to shut down the whole program.</p>
<pre><code class="language-java">import java.util.*; // importing everything

public class sample {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int x = 1;
        
        do{
            try{
                System.out.println(&quot;Enter first num: &quot;);
                int n1 = input.nextInt();
                System.out.println(&quot;Enter second num: &quot;);
                int n2 = input.nextInt();
                int sum = n1 / n2; // where the error might occur
                System.out.println(sum);
                x = 2; // runs successfully only without errors
            } catch (Exception e) { // any error
                System.out.println(&quot;You can't do this. &quot;);
            }
        } while(x == 1);
    }
}
</code></pre>
<p>Another sample:<br>
<code>throw new RuntimeException(&quot;Busted!&quot;)</code><strong>?</strong></p>
<h3 id="tostring">.toString()</h3>
<p>All Java objects have a toString() method since all classes inherit from Object. It returns a String object which used for debugging instead of formatted screen / file output.</p>
<pre><code class="language-java">@Override // To prevent typo
public String toString() {
	return getClass.getName() // returns the name of object
		+ &quot; [daField1 = &quot; + daField1
		+ &quot;, daField2 = &quot; + daField2 + &quot;]&quot;;
}
</code></pre>
<h3 id="pass-by-value">Pass by Value</h3>
<p>Java uses pass by value.</p>
<ul>
<li>Passing a primitive type passes its value.</li>
<li>Passing an object passes (by value) a reference to the object</li>
</ul>
<p>This means:</p>
<ul>
<li>When passed a primitive type, changes inside a method have no effect outside the method.</li>
<li>When passed an object, you can modify its state.</li>
<li>You cannot change which object the passed parameter points to.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 09 - Introduction to UIKit Part 5]]></title>
        <id>https://jenkinsxu.github.io/post/day-09-introduction-to-uikit-part-5</id>
        <link href="https://jenkinsxu.github.io/post/day-09-introduction-to-uikit-part-5">
        </link>
        <updated>2020-01-13T19:09:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="controls-responding-to-user-input">Controls (Responding to user input)</h2>
<p>When the user interacts with a control, the <strong>control triggers</strong> a <strong>control event</strong>. Different controls trigger different control events.</p>
<p>After setting up a control in Interface Builder, you set up an <strong>IBAction</strong> that responds to a specific control event and allows you to execute a block of code.<br>
Most often you will use the Primary Action Triggered <code>UIControl.Event.primaryActionriggered</code>control event. This control event is triggered when <strong>a button is tapped</strong> or when <strong>the value of a control changes</strong>.</p>
<h3 id="buttons-uibutton">Buttons <code>UIButton</code></h3>
<p><img src="https://jenkinsxu.github.io/post-images/1579057827392.png" alt="" loading="lazy"><br>
The primary control is triggered when</p>
<ul>
<li>the user <strong>releases a button after tapping it</strong></li>
<li>the user <strong>first touches the button</strong></li>
<li>the user <strong>holds down the button</strong></li>
<li>the user cancels the tap by <strong>dragging their finger outside of the frame</strong> of the button before lifting their finger.</li>
</ul>
<h3 id="segmented-controls-uisegmentedcontrol">Segmented Controls <code>UISegmentedControl</code></h3>
<figure data-type="image" tabindex="1"><img src="https://jenkinsxu.github.io/post-images/1579057838404.png" alt="" loading="lazy"></figure>
<ul>
<li>Each segment functions as a discrete button.<br>
<img src="https://jenkinsxu.github.io/post-images/1579057844085.png" alt="" loading="lazy"><br>
Segmented controls execute code when the control’s value changes. The value <strong>represents which segment of the control is selected</strong>.</li>
</ul>
<h3 id="text-fields-uitextfield">Text Fields <code>UITextField</code></h3>
<p>Text fields allow the user to input a <strong>single line</strong> of text into an app.<br>
<img src="https://jenkinsxu.github.io/post-images/1579057852817.png" alt="" loading="lazy"><br>
Text fields execute code when the user <strong>presses the &quot;Return&quot; or &quot;Done&quot;</strong> key on keyboard or when the user <strong>edits the text</strong>.</p>
<h3 id="sliders-uislider">Sliders <code>UISlider</code></h3>
<figure data-type="image" tabindex="2"><img src="https://jenkinsxu.github.io/post-images/1579057860001.png" alt="" loading="lazy"></figure>
<h3 id="switches-uiswitch">Switches <code>UISwitch</code></h3>
<figure data-type="image" tabindex="3"><img src="https://jenkinsxu.github.io/post-images/1579057865815.png" alt="" loading="lazy"></figure>
<h3 id="date-pickers">Date Pickers</h3>
<figure data-type="image" tabindex="4"><img src="https://jenkinsxu.github.io/post-images/1579057871731.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 07 - Introduction to UIKit Part 3]]></title>
        <id>https://jenkinsxu.github.io/post/day-07-introduction-to-uikit-part-3</id>
        <link href="https://jenkinsxu.github.io/post/day-07-introduction-to-uikit-part-3">
        </link>
        <updated>2020-01-04T06:49:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="25-collections">2.5 Collections</h2>
<h3 id="arrays">Arrays</h3>
<pre><code class="language-swift">var names: [String] = [&quot;Anne&quot;, &quot;Gary&quot;, &quot;Keith&quot;]
var numbers: [Int8] = [1, -3, 50, 72, -95] // [-127, 128]
</code></pre>
<pre><code class="language-swift">var names = [&quot;Anne&quot;, &quot;Gary&quot;, &quot;Keith&quot;]
let numbers = [1, -3, 50, 72, -95] 

// Check if a certain value exist in an array. 
if numbers.contains(5) {
	print(&quot;There is a 5&quot;)
}
</code></pre>
<h3 id="initialization-of-empty-arrays">Initialization of empty arrays</h3>
<pre><code class="language-swift">var myArray: [Int] = []
</code></pre>
<pre><code class="language-swift">var myArray: Array&lt;Int&gt; = []
</code></pre>
<pre><code class="language-swift">// All objects can be initialized by adding a () after the type name. 
var myArray = [Int]()
</code></pre>
<h3 id="repeating-elements">Repeating elements</h3>
<pre><code class="language-swift">var myArray = [Int](repeating: 0, count: 100) // An array filled with 100 zeros. 
</code></pre>
<h3 id="the-count-and-isempty-properties">The .count and .isEmpty properties</h3>
<ul>
<li>.count: The number of items within an array.</li>
<li>.isEmpty: Check if the array is empty.</li>
</ul>
<h3 id="the-subscript-syntax">The subscript Syntax</h3>
<ul>
<li>zero-indexed</li>
</ul>
<pre><code class="language-swift">names[0]
</code></pre>
<h3 id="adding-and-removing-elements">Adding and removing elements</h3>
<pre><code class="language-swift">var names = [&quot;Amy&quot;]
names.append(&quot;Joe&quot;)
names += [&quot;Keith&quot;, &quot;Jane&quot;] // Adding multiple elements at a time
names.insert(&quot;Bob&quot;, at: 0)

let chelsea = names.remove(at: 2)
let dan = names.removeLast()
names.removeAll()

var myNewArray = firstArray + secondArray
</code></pre>
<hr>
<h3 id="dictionary">Dictionary</h3>
<pre><code class="language-swift">var myDictionary = [String: Int]()

var myDictionary = Dictionary&lt;String, Int&gt;()

var myDictionary: [String: Int] = [:]
</code></pre>
<h3 id="addremovemodify-a-dictionary">Add/Remove/Modify a dictionary</h3>
<pre><code class="language-swift">numberOfLegs[&quot;snake&quot;] = 0

// If there was no value, oldValue will be nil.
let oldValue = scores.updateValue(100, forKey: &quot;Richard&quot;)

// Run code only if a value is returned from the method.
if let oldValue = scores.updateValue(100, forKey: &quot;Richard&quot;) {
	print(&quot;Richard’s old value was \(oldValue)&quot;)
}

// To remove an item from a dictionary, you can use subscript syntax, setting the value to nil. 
// If you need the old value returned before removing it: 
if let oldValue = scores.removeValue(forKey: &quot;&quot;Luke) {
	print(&quot;Luke’s score was \(oldValue) before he stopped playing&quot;)
}
</code></pre>
<h3 id="accessing-a-dictionary">Accessing a dictionary</h3>
<pre><code class="language-swift">let players = Array(scores.keys)
let points = Array(scores.values)

// Execute when exists
if let myScore = scores[&quot;Luke&quot;] {
	print(myScore)
}
</code></pre>
<h2 id="26-loops">2.6 Loops</h2>
<h3 id="for-in-loop">for-in Loop</h3>
<pre><code class="language-swift">for _ 1…3 {
	print(&quot;Hello!&quot;)
}

names = [&quot;Joseph&quot;, &quot;Cathy&quot;, &quot;Winston&quot;]
for name in names {
	print(&quot;Hello, \(name)&quot;)
}

for letter in &quot;ABCD&quot; {
	print(&quot;The letter is \(letter)&quot;)
}

// If you need the index of each element in addition to its value, you can use the enumerated() method (to return a tuple containing both the index and the value of each item)
for (index, letter) in &quot;ABCD&quot;.enumerated() {
	print(&quot;\(index): \(letter)&quot;)
}

let vehicles = [&quot;unicycle&quot;: 1, &quot;bicycle&quot;: 2, &quot;tricycle&quot;: 3, &quot;quad bike&quot;: 4]
for (vehicleName, wheelCount) in vehicles {
	print(&quot;A \(vehicleName) has \(wheelCount) wheels&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 08 - Introduction to UIKit Part 4]]></title>
        <id>https://jenkinsxu.github.io/post/day-08-introduction-to-uikit-part-4</id>
        <link href="https://jenkinsxu.github.io/post/day-08-introduction-to-uikit-part-4">
        </link>
        <updated>2020-01-03T20:17:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="27-introduction-to-uikit">2.7 Introduction to UIKit</h2>
<ul>
<li>The foundational class for all visual elements defined in UIKit is the <strong>UIView</strong>, or view. A view defines a rectangular shape that can be customized to display anything on the screen. Text, images, lines, and graphics all depend on UIView as the base.</li>
</ul>
<h3 id="special-uiview-subclasses">Special UIView subclasses</h3>
<ul>
<li>UILabel: displays text</li>
<li>UIImageView: displays an image</li>
<li>UIScrollView: allows you to put scrollable content onto the screen</li>
</ul>
<h3 id="a-view-hierarchy">A view hierarchy</h3>
<p><img src="https://jenkinsxu.github.io/post-images/1578255468953.png" alt="" loading="lazy"><br>
Views are often nested. A view that’s contained in another view is called a <strong>child view</strong> (e.g. a cell). A view that contains one or more views is called a <strong>parent view</strong> (e.g. a table view).</p>
<p>To display a view onscreen: give it a frame and add it to the view hierarchy.</p>
<ul>
<li>When adding a view in Interface Builder, its background color is white by default.</li>
<li>When adding a view in code, the background color is transparent by default.</li>
</ul>
<h3 id="attributes-of-views">Attributes of views</h3>
<figure data-type="image" tabindex="1"><img src="https://jenkinsxu.github.io/post-images/1578255479749.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="displaying-information-to-users">Displaying information to users</h2>
<h3 id="label-uilabel">Label (UILabel)</h3>
<p>Labels use <strong>static</strong> text to relay information to the user.<br>
<img src="https://jenkinsxu.github.io/post-images/1578255489380.png" alt="" loading="lazy"></p>
<h3 id="image-view">Image View</h3>
<p>An image view displays an image or an animated sequence of images.<br>
<img src="https://jenkinsxu.github.io/post-images/1578255498395.png" alt="" loading="lazy"></p>
<h3 id="text-view-uitextview">Text View (UITextView)</h3>
<p>A text view allows the user to input text in your app. You’ll typically use a text view to display a large amount of text, such as the body of an email message.<br>
<img src="https://jenkinsxu.github.io/post-images/1578255507711.png" alt="" loading="lazy"></p>
<h3 id="scroll-view-uiscrollview">Scroll View (UIScrollView)</h3>
<p>You’ll typically use a scroll view when the information you want to display is larger than the device’s screen.<br>
<img src="https://jenkinsxu.github.io/post-images/1578255516409.png" alt="" loading="lazy"></p>
<h3 id="table-view-uitableview">Table View (UITableView)</h3>
<p><img src="https://jenkinsxu.github.io/post-images/1578255524295.png" alt="" loading="lazy"><br>
A table view presents data in a single scrollable column of rows and sections, allowing users to navigate easily through groups of information. Table views are an excellent format for displaying and editing <strong>hierarchical lists of information</strong>.<br>
<img src="https://jenkinsxu.github.io/post-images/1578255531409.png" alt="" loading="lazy"></p>
<h3 id="toolbars-uitoolbar">Toolbars (UIToolbar)</h3>
<p>A toolbar usually appears at the bottom of a screen and displays one or more buttons, called <strong>bar button items</strong>.<br>
<img src="https://jenkinsxu.github.io/post-images/1578255539123.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="2"><img src="https://jenkinsxu.github.io/post-images/1578255545038.png" alt="" loading="lazy"></figure>
<h3 id="navigation-bars-uinavigationbar">Navigation Bars (UINavigationBar)</h3>
<p><img src="https://jenkinsxu.github.io/post-images/1578255553420.png" alt="" loading="lazy"><br>
<img src="https://jenkinsxu.github.io/post-images/1578255559223.png" alt="" loading="lazy"></p>
<h3 id="tab-bars-uitabbar">Tab Bars (UITabBar)</h3>
<p>A tab bar provides easy access to different views in an app. The most common way to use a tab bar is with a <strong>tab bar controller</strong>, which holds a property of each view controller that represents each scene you want presented in the tab bar. You’ll add <strong>scenes</strong> to be displayed to the controller, and the tab bar view, you link it to the tab bar controller's viewControllers property in a storyboard (<strong>?</strong>). The view controller for each scene has a <strong>UITabBarItem</strong> property that <strong>defines the text and optional image that will be displayed by the tab bar</strong>.</p>
<hr>
<h2 id="responding-to-user-input">Responding to user input</h2>
<p>unfinished</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 06 - Introduction to UIKit Part 2]]></title>
        <id>https://jenkinsxu.github.io/post/day-06-introduction-to-uikit-part-2</id>
        <link href="https://jenkinsxu.github.io/post/day-06-introduction-to-uikit-part-2">
        </link>
        <updated>2020-01-02T10:32:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="24-classes-inheritance">2.4 Classes, Inheritance</h2>
<ul>
<li>As a basic rule, you should start new types as structures until you need one of the features that classes provide.</li>
<li>Start with a class when you’re working with a framework (ex. <strong>Foundation</strong> or <strong>UIKit</strong>) that uses classes (since many of them have method calls that expect certain things to be classes) or you want to refer to the same instance of a type in multiple places. (<strong>Reference</strong>)</li>
</ul>
<h3 id="create-a-subclass-and-override-methods-and-properties">Create a Subclass and Override Methods and Properties</h3>
<pre><code class="language-swift">class Vehicle {
	var currentSpeed = 0.0

	var description: String {
		return “traveling at \(currentSpeed) miles per hour”
	}

	func makeNoise() {
		
	}
}

class Train: Vehicle {
	override func makeNoise() {
		print(“Choo Choo!”)
	}
}

// You can also override properties by providing a getter, or a block of code that returns the value, like a computed property

// Accesses the description from the superclass by calling super.description

class Car: Vehicle {
	var gear = 1
	override var description: String {
		return super.description + “ in gear \(gear)”
	}
}
</code></pre>
<h3 id="override-initializer">Override Initializer</h3>
<pre><code class="language-swift">class Person {
	let name: String 

	// Swift does not create a member wise initializer for classes. 
	init(name: String) {
		self.name = name
	}
}

class Student: Person {
	var favoriteSubject: String
	
	init(name: String, favoriteSubject: String) {
		self.favoriteSubject = favoriteSubject
		super.init(name: name)
	}
}
</code></pre>
<h3 id="references">References</h3>
<p>Constants or variables that are assigned to an instance store that instance’s address to refer to the instance. So the constant or variable does not contain the value itself, it points to the value in memory. We say the data has a <strong>stable identity</strong>. Updating them as parameter will also update their values.</p>
<pre><code class="language-swift">class Person {
	let name: String
	var age: Int

	init(name: String, age: Int) {
		self.name = name
		self.age = age
	}
}
var jack = Person(name: “Jack”, age: 24)
var myFriend = jack

jack.age += 1

print(jack.age == myFriend.age) // true

// In contrast, when you create an instance of a structure, you’re assigning a literal value to that variable instead of an address. If you create a variable that's equal to another structure variable, the value is copied. 

struct Person {
	var name: String
	var age: Int
}

var jack = Person(name: ”Jack”, age: 24)
var myFriend = jack

jack.age += 1

print(jack.age == myFriend.age) // false
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 05 - Introduction to UIKit Part 2 ]]></title>
        <id>https://jenkinsxu.github.io/post/day-05-introduction-to-uikit-part-2</id>
        <link href="https://jenkinsxu.github.io/post/day-05-introduction-to-uikit-part-2">
        </link>
        <updated>2020-01-02T02:23:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="22-functions">2.2 Functions</h2>
<ul>
<li>A function in Swift can return zero, one or <strong>multiple values</strong>.</li>
</ul>
<h3 id="defining-a-function">Defining a Function</h3>
<pre><code class="language-swift">func functionName (argumentLabel: TypeOfParameter) -&gt; ReturnType {
	//body of the function
}

functionName (parameters: value) //calling the function
</code></pre>
<h3 id="argument-labels-and-local-names">Argument Labels and Local Names</h3>
<pre><code class="language-swift">// specify an external name before the local one
func sayHello(to person: String, and anotherPerson: String) {
	print(“Hello \(person), and \(anotherPerson)”)
}

sayHello(to: “Miles”, and: “Riley”)
</code></pre>
<h3 id="omitting-the-argument-label">Omitting the Argument Label</h3>
<pre><code class="language-swift">func sayHello(_ person: String, _anotherPerson: String) {
	print(“Hello” \(person) and \(anotherPerson))
}

sayHello(“Miles”, “Riley”)
</code></pre>
<h3 id="default-parameter-values">Default Parameter Values</h3>
<p>You’ll need to place all parameters with default values <strong>at the end of the list</strong>, and these parameters must <strong>all have argument labels</strong>.</p>
<pre><code class="language-swift">func display(teamName: String, score: Int = 0) {
	print(“\”(teamName): \(score))
}

display(teamName: “Wombats”, score: 100) //“Wombats: 100”
display(teamName: “Wombats”) //“Wombats: 0”
</code></pre>
<h2 id="23-structures">2.3 Structures</h2>
<ul>
<li>As a general rule, you should use let whenever possible to define an instance of a structure, and use var when defining the properties of a structure (easier for creating new instance from the current ones).</li>
</ul>
<h3 id="default-initializer">Default Initializer</h3>
<pre><code class="language-swift">var string = String.init() // “”
var integer = Int.init() // 0
var bool = Bool.init() // false

// Shorthand version
string = String()
integer = Int()
bool = Bool()
</code></pre>
<h3 id="different-approaches-to-initializing-property-values">Different Approaches to Initializing Property Values</h3>
<ol>
<li><strong>Default Values</strong></li>
</ol>
<pre><code class="language-swift">struct Odometer {
	var count: Int = 0
}
</code></pre>
<ol start="2">
<li><strong>Member-wise Initializer</strong><br>
Member-wise initializers are the correct approach when there’s not a default state for new instance of your type.</li>
</ol>
<pre><code class="language-swift">struct Person {
	var name: String
}

let person = Person(name: “Michelle”) // Member-wise initializer
</code></pre>
<ol start="3">
<li><strong>Custom Initializers</strong><br>
For the times when you want to define an initializer that completes some custom logic before assigning all of the properties.<br>
Custom initializers have the same requirement as default and member-wise initializers: All properties must be set to initial values before completing initialization.</li>
</ol>
<pre><code class="language-swift">struct Temperature {
	var celsius: Double
	
	init(celsius: Double) {
		self.celsius = celsius
	}

	// When you add a custom initializer to a type definition, you must define your own member-wise initializer; Swift no longer provides one for you. 

	init(fahrenheit: Double) {
		celsius = (fahrenheit - 32) / 1.8
	}
}

let boiling = Temperature(fahrenheit: 212.0)
</code></pre>
<h3 id="mutating-methods">Mutating Methods</h3>
<p>Occasionally you’ll want to update the property values of a structure within an instance method. To do so you’ll need to add the mutating keyword.</p>
<pre><code class="language-swift">struct Odometer {
	var count: Int = 0

	mutating func increment() {
		count += 1
	}

	mutating func increment(by amount: Int) {
		count += amount
	}
}
</code></pre>
<h3 id="computed-properties">Computed Properties</h3>
<p>With computed properties, you can create properties that can compute their value based on other instance properties or logic. You must also explicitly declare the type.</p>
<pre><code class="language-swift">struct Temperature {
	var celsius: Double

	var fahrenheit: Double {
		return celsius * 1.8 + 32
	}

	var kelvin: Double {
		return celsius + 273.15
	
}

// The logic contained in a computed property will be executed each time the property is accessed, so the returned value will always bt up to date. 
</code></pre>
<h3 id="property-observers">Property Observers</h3>
<p>Property observers are called every time a property’s value is set.<br>
There are two observer closures, or blocks of code, that you can define on any given property: willSet, and didSet.<br>
Whenever the variable is modified, <strong>willSet will be called first</strong>, and you’ll have access to the new value that will be set to the property value in a constant named <strong>newValue</strong>.<br>
After the property’s value has been updated, <strong>didSe</strong>t will be called, and you can access the previous property value using <strong>oldValue</strong>.</p>
<pre><code class="language-swift">struct StepCounter {
	var totalSteps: Int = 0 {
		willSet {
			print(“About to set totalSteps to \(newValue)”)
		}
		didSet {
			if totalStep &gt; oldStep {
				print(“Added \(totalSteps - OldValue) steps”)
			}
		}
	}
}
</code></pre>
<h3 id="type-properties-and-methods-different-from-instance-methods">Type Properties and Methods (Different from Instance Methods)</h3>
<p>Type properties are useful when a property is related to the type, but not a characteristic of an instance itself.</p>
<pre><code class="language-swift">struct Temperature {
	static var boilingPoint = 100
}

let boilingPoint = Temperature.boilingPoint
</code></pre>
<p>The Double structure, defined in the Swift Standard Library, contains a static method called minimum that returns the smaller of its two parameters.</p>
<pre><code class="language-swift">let smallerNumber = Double.minimum(100.0, -1000.0)
</code></pre>
<h3 id="deep-copying">(Deep) Copying</h3>
<p>If you assign a structure to a variable or pass an instance as a parameter into a function, the values are copied. (Changing one value doesn’t change the other. )</p>
<h3 id="self">Self</h3>
<p>In Swift, <strong>self</strong> refers to the <strong>current instance</strong> of the object.</p>
<pre><code class="language-swift">self.color
</code></pre>
<p>The Swift compiler recognizes when property or method names exist on the current object, and makes using self optional.<br>
The use of self is required within initializers that have parameter names that match property names (<strong>shadowing</strong>).</p>
<pre><code class="language-swift">struct Temperature {
	var celsius: Double
	init(celsius: Double) {
		self.celsius = celsius
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 04 - Introduction to UIKit Part 1]]></title>
        <id>https://jenkinsxu.github.io/post/day-04-introduction-to-uikit-part-1</id>
        <link href="https://jenkinsxu.github.io/post/day-04-introduction-to-uikit-part-1">
        </link>
        <updated>2019-12-31T17:56:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="21-strings">2.1 Strings</h2>
<h3 id="string-literals">String Literals</h3>
<pre><code class="language-swift">&quot;Hello Michelle!&quot;
</code></pre>
<p>If your string literal needs to be multiple lines, simply surround your set of characters with three double quotation marks &quot;&quot;&quot;</p>
<pre><code class="language-swift">let joke = &quot;&quot;&quot;
    Q: why did the chicken cross the road?
    A: To get to the other side! 
    &quot;&quot;&quot;
</code></pre>
<p>Escape character</p>
<pre><code class="language-swift">let greeting = &quot;It is traditional in programming to print \&quot;Hello, world\&quot;&quot;
</code></pre>
<ul>
<li>Double quote <strong>&quot;</strong></li>
<li>Single quote **' **</li>
<li>Backslash <strong>\</strong></li>
<li>Tap <strong>\t</strong></li>
<li>Carriage return <strong>\r</strong></li>
</ul>
<h3 id="check-if-a-swift-string-is-empty-using-the-boolean-property">Check if a Swift String is empty using the Boolean <strong>property</strong></h3>
<pre><code class="language-swift">var myString = &quot;&quot;
if myString.isEmpty {
    print(&quot;The string is empty&quot;)
}
</code></pre>
<h3 id="concatenation-kənˌkætəˈneɪʃn">Concatenation [kənˌkætəˈneɪʃn]</h3>
<pre><code class="language-swift">let myString = string1 + string2
</code></pre>
<h3 id="string-interpolation-ɪnˌtɜːrpəˈleɪʃn">String Interpolation [ɪnˌtɜːrpəˈleɪʃn]</h3>
<pre><code class="language-swift">print(&quot;If a is \(a) and b is \(b), then a + b equals \(a+b)&quot;) 
</code></pre>
<h3 id="useful-methods-of-the-string-type">Useful methods of the String type</h3>
<ul>
<li>.lowercased()</li>
<li>.hasPrefix(_😃</li>
</ul>
<pre><code class="language-swift">let gretting = &quot;Hello, world!&quot;
gretting.hasPrefix(&quot;Hello&quot;)
</code></pre>
<ul>
<li>.hasSuffix(_😃</li>
<li>.contains(_😃</li>
<li>.index(before: ) //Returns the position immediately before the given index.</li>
<li>.index(after: )</li>
<li>index(_:offsetBy:)</li>
</ul>
<pre><code class="language-swift">let s = &quot;Swift&quot;
let i = s.index(s.startIndex, offsetBy: 4)
print(s[i])
// Prints &quot;t&quot;
</code></pre>
<ul>
<li>insert(contentsOf:at:)</li>
<li>remove(at:)</li>
<li>removeSubrange(_😃</li>
<li>replaceSubrange(_:, with:)</li>
</ul>
<h3 id="useful-properties-of-the-string-type">Useful properties of the String type</h3>
<ul>
<li>.count</li>
<li>.startIndex //The position of the first character in a nonempty string.</li>
<li>.endIndex</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 03 - Getting Started with App Development Part 3]]></title>
        <id>https://jenkinsxu.github.io/post/day-03-getting-started-with-app-development-part-3</id>
        <link href="https://jenkinsxu.github.io/post/day-03-getting-started-with-app-development-part-3">
        </link>
        <updated>2019-12-28T19:25:02.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Swift booleans have a method, **toggle() **</li>
<li>Command-Shift-L to view library</li>
</ul>
<h3 id="setting-background-color">Setting background color</h3>
<pre><code class="language-swift">view.backgroundColor = .white
</code></pre>
<ul>
<li>UIControl.State represents the different potential states of a button (a data type?)</li>
</ul>
<h3 id="a-normal-button">A &quot;normal&quot; button</h3>
<pre><code class="language-swift">static var normal: UIControl.State //Define a normal constant corresponding to the state of the button when it's enabled and sitting idle on the screen
</code></pre>
<h3 id="changing-a-title">Changing a title</h3>
<pre><code class="language-swift">lightButton.setTitle(&quot;Off&quot;, for: .normal)
</code></pre>
<h3 id="clear-out-unused-outlets-with-connection-panel">Clear out unused outlets with connection panel</h3>
]]></content>
    </entry>
</feed>