<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jenkinsxu.github.io</id>
    <title>Jenkins&apos; Secret Base</title>
    <updated>2020-06-25T18:06:14.639Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jenkinsxu.github.io"/>
    <link rel="self" href="https://jenkinsxu.github.io/atom.xml"/>
    <logo>https://jenkinsxu.github.io/images/avatar.png</logo>
    <icon>https://jenkinsxu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Jenkins&apos; Secret Base</rights>
    <entry>
        <title type="html"><![CDATA[Object Oriented Design - Software Creation Phases - Part 1]]></title>
        <id>https://jenkinsxu.github.io/post/object-oriented-design-software-creation-phases-part-1/</id>
        <link href="https://jenkinsxu.github.io/post/object-oriented-design-software-creation-phases-part-1/">
        </link>
        <updated>2020-03-16T07:13:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="terminology">Terminology</h1>
<p><code>OOD</code>: Object Oriented Design<br>
<code>OOP</code>: Object Oriented Programming</p>
<h1 id="software-creation-phases">Software Creation Phases</h1>
<h2 id="1-requirements-gathering">1. Requirements Gathering</h2>
<ul>
<li>The goal of requirements gathering is to create a complete description (a &quot;spec&quot;) of <strong>what</strong> (not how) the software product is to do.</li>
<li>The product is a üìú<strong>Functional Specification</strong> that completely describe the <strong>task to be performed</strong> (what to do) and states üß±<strong>constraints on development</strong> (what not to do) and operation.</li>
</ul>
<h2 id="2-design-implementation">2. Design &amp; Implementation</h2>
<h3 id="21-object-oriented-design">2.1 Object Oriented Design</h3>
<ul>
<li>The goal of OOD is üîç<strong>identification</strong> of classes, their üë®‚Äçüíº<strong>responsibilities</strong> and üíï<strong>relationships</strong> among them.</li>
</ul>
<hr>
<h3 id="identifying-classes">‚≠ê Identifying Classes ‚≠ê</h3>
<p>Given a problem specification, there are 3 possible categories of classes:</p>
<ol>
<li>Classes are often <strong>the nouns</strong> while some nouns may be properties of other object. E.g. When <code>customers</code> call to report a <code>product's defect</code>, the <code>user</code> must record: product <code>serial number</code>, the <code>defect description</code>, and <code>defect severity</code>.</li>
<li><strong>Utility classes</strong>: stacks, queues, trees, etc.</li>
<li>Other possible classes:</li>
</ol>
<ul>
<li><strong>Agents</strong>: Does a special task. Name often ends in &quot;or&quot; / &quot;er&quot;. Ex. <code>Scanner</code>;</li>
<li><strong>Events &amp; Transactions</strong>: Ex: <code>MouseEvent</code>, <code>KeyPress</code>;</li>
<li><strong>Users &amp; Roles</strong>: Model the user. Ex: <code>Administrator</code>, <code>Cashier</code>, <code>Accountant</code>;</li>
<li><strong>Systems</strong>: Sub system, or the controlling class for a full system;</li>
<li><strong>System interfaces / devices</strong>: Interact with the OS. Ex: <code>File</code>;</li>
<li><strong>Foundational Classes</strong>: <code>Date</code>, <code>String</code>, <code>Rectangle</code>...Use these without modelling them.
<ul>
<li>Don't over use <code>String</code>. Only use if your data type is nature a string (such as a name). Create classes or enums like <code>Department</code>, <code>Course</code> or <code>Model</code>.
<ul>
<li>Strings are problematic to compare and store. (&quot;cmpt213&quot; and &quot;CMPT213&quot;)</li>
<li>Even if going from string data (ex: text file) to string data (ex: screen output), convert to non-string type internally.<br>
Poor idea for setting direction:</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// May have other constants
public const int HORIZONTAL = 0; 
public const int VERTICAL   = 1; 
</code></pre>
<p>Enums are better a type. Incorrect argument type generates error. Therefore using enums converts a logic error into compile time error.</p>
<pre><code class="language-java">public enum Direction {
	HORIZONTAL, VERTICAL // Infact constant static instances
}
// Compiler enforces correct type checking
public void printPage(Direction pageDirection);
// Call it with: 
printPage(Direction.HORIZONTAL);
</code></pre>
<hr>
<hr>
<h3 id="identifying-responsibilities">‚≠ê Identifying Responsibilities ‚≠ê</h3>
<p>Look for verbs in the problem description. Assign each responsibility to exactly <strong>one</strong> class. Let <code>Main</code> have higher level abstraction.<br>
There are 2 things to pay attention to:</p>
<ol>
<li>Responsibility Heuristic<br>
Avoid exposing the internals of an object just for access by another (not just a data class).<br>
Example:<br>
Task: &quot;Adding a <code>Page</code> to a 3-ring <code>Binder</code>. &quot;<br>
<code>myPage.addToBinder(daBinder);</code><br>
Using this method, we must get access inside the <code>Binder</code>.<br>
<code>daBinder.addPage(myPage);</code><br>
Using this method, we do not need internal access to the <code>Page</code>.</li>
<li>Functionality often in the wrong class<br>
If a method calls methods on another object more than this object, move it to that other class.</li>
</ol>
<hr>
<hr>
<h3 id="identifying-responsibilities-2">‚≠ê Identifying Responsibilities ‚≠ê</h3>
<h3 id="types-of-relations-between-classes">Types of Relations between classes</h3>
<ul>
<li><strong>Dependency</strong><br>
Where a class <strong>&quot;uses&quot;</strong> another class. Two classes are <strong>coupled</strong> if one depends on the other (<strong>coupling</strong>). Coupling makes it harder to change a system because more parts need to change at once, and therefore, one of our design goal is to reduce coupling.<br>
Ex: Any of our programs using <code>System</code>. <code>return name;</code> has lower coupling than <code>System.our.println(name);</code> (coupled to <code>System</code>).</li>
<li><strong>Aggregation</strong><br>
Where a class <strong>‚Äúhas-a‚Äù</strong> object of another class in it, usually through the object's fields. Ex: <code>Car</code> has-an <code>Engine</code>. Aggregation a special case of Dependency: If you &quot;have&quot; an object of a type, you must use &quot;depend&quot; on the corresponding class. Foundational classes (<code>String</code>, <code>Data</code>, ... ) are not usually considered part of aggregation.
<ul>
<li><strong>Multiplicity</strong>
<ul>
<li>1:0...1</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">class Person {
	private Car myCar;
}
</code></pre>
<pre><code>	* 1:*
</code></pre>
<pre><code class="language-java">class Album {
	private List&lt;Song&gt; songs;
}
</code></pre>
<ul>
<li><strong>Inheritance</strong><br>
Where a class <strong>‚Äúis-a‚Äù</strong> sub-category of another class. Ex: <code>Eagle</code> is-a <code>Bird</code>. Heuristic: Use dependency (or aggregation) over inheritance  when possible.</li>
</ul>
<hr>
<ul>
<li>The products is a üìà<strong>diagram</strong> of classes and relationships between them or üóí<strong>text description</strong> of classes.</li>
</ul>
<p>The design Process is an <strong>iterative</strong> process of discovery and refinement and it is time consuming, but a good design speeds up implementation.</p>
<blockquote>
<p>The sooner you start, the longer it takes.</p>
</blockquote>
<p>It is a <strong>wicked problem</strong>. You need a good design to implement the system, but you need to implement the system to know if you have a good design. So it can only be sloppy: we might make many mistakes and mis-steps, but it is cheaper during design than implementation.</p>
<p>Therefore, OOD is a <strong>heuristic process</strong>:</p>
<ul>
<li>We use <strong>rule of thumb</strong>, rather than fixed process.</li>
<li>We use <strong>trail</strong> to find errors, do analysis and make refinement.</li>
</ul>
<hr>
<h3 id="designing-classes">‚≠ê Designing Classes ‚≠ê</h3>
<h3 id="concepts">Concepts:</h3>
<p><code>Object</code>: A software entity with <strong>state (fields)</strong>, <strong>behaviours (methods)</strong> to operate on the state, and unique <strong>identity (memory address)</strong>.<br>
<code>State</code>: All information an object stores.<br>
<code>Behaviour</code>: The methods or operations it supports for using and changing its state. (Not all possible operations supported.)<br>
<code>Identity</code>: Able to differentiate two identical objects.<br>
<code>Class</code>: The type of a set of objects with <strong>same behaviours</strong> and set of <strong>possible states</strong>.</p>
<h3 id="class-naming">Class Naming</h3>
<p>To name a class we:</p>
<ul>
<li>Make class names <strong>singular</strong></li>
<li>Avoid redundant &quot;object&quot; in names</li>
</ul>
<hr>
<h3 id="22-implementation">2.2 Implementation</h3>
<ul>
<li>The goal of implementation is to program, test, and deploy the software product.</li>
</ul>
<p>There are two process options:</p>
<ol>
<li><strong>Skeleton Code ü¶¥</strong>: Implement minimal parts / feature of full system first, then flush out code.</li>
<li><strong>Component Wise ü§ñ</strong>: Implement one class/component at a time.</li>
</ol>
<p>And there are two ways of intergration:</p>
<ol>
<li><strong>Continual Integrationüö∞</strong>: Gradual growth of the system by continually integrating changes.</li>
<li><strong>Big Bang Integration üß®</strong>: build parts separately, then assemble at once. [Fraught with peril üò•]</li>
</ol>
<h2 id="3-verification">3. Verification</h2>
<h2 id="4-evolution">4. Evolution</h2>
<p>Change is inevitable for software. OOD works well with software change because classes represent stable problem domain concepts.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java for C++ Programmer]]></title>
        <id>https://jenkinsxu.github.io/post/java-for-c-programmer/</id>
        <link href="https://jenkinsxu.github.io/post/java-for-c-programmer/">
        </link>
        <updated>2020-02-09T06:52:21.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h1 id="class-and-interface">Class and Interface</h1>
<h2 id="classes">Classes</h2>
<p>Use the  <code>final</code>      keyword to prevent class inheritance.<br>
Use the  <code>extends</code>  keyword to achieve class inheritance.</p>
<pre><code class="language-java">// Can have nested classes, but no more than one full class in  a file
public class Vehicle {
	protected String brand = &quot;Ford&quot;;
	public void honk() {
    System.out.println(&quot;Tuut, tuut!&quot;);
  }
	// arug is from terminal input
	// static: excuse it without instantiating the object
	// no linking errors when multiple main()'s in classes
	public static void main(String[] arug) {
		System.out.println(&quot;Hello, world.&quot;);
	}
}
class Car extends Vehicle {
  private String modelName = &quot;Mustang&quot;;
  public static void main(String[] args) {
    Car myCar = new Car();
    myCar.honk();
    System.out.println(myCar.brand + &quot; &quot; + myCar.modelName);
  }
}
</code></pre>
<h2 id="interface-empty-bodies">Interface (&quot;empty bodies&quot;)</h2>
<p>A class that implement interface must implement all the methods declared in the interface. A class can implement more than one interface.</p>
<p>If a class implements an interface and does not provide method bodies for <strong>all functions</strong> specified in the interface, then the class must be declared <strong>abstract</strong>.</p>
<p>Abstract classes may contain non-final variables.</p>
<p>All the <strong>methods</strong> in an interface are declared with an empty body and <strong>are public</strong> and all <strong>fields are public, static and final</strong> by default.</p>
<pre><code class="language-java">interface Animal {
	final int id = 10;
	void animalSound();
	default void display() {
		System.out.println(&quot;Hello!&quot;); 
	}
}

class Pig implements Animal {
	// public method
	public void animalSound() {
		System.out.println(&quot;wee wee&quot;);
	}
	public static void main (String args[]) {
		// public and static field
		System.out.println(id); 
		
		Pig test = new Pig();
		test.displau();
	}
}
</code></pre>
<h2 id="generic-classes">Generic Classes</h2>
<p>Use <code>&lt;T&gt;</code> after the class name to create a generic class.</p>
<pre><code class="language-java">public class GenericsType&lt;T&gt; {
	private T t;
	public T get(){
		return this.t;
	}
	public void set(T t1){
		this.t=t1;
	}
	public static void main(String args[]){
	}
}
</code></pre>
<h2 id="static">Static</h2>
<ul>
<li>Static methods / class methods</li>
<li>Static field / class data
<ul>
<li>Often used for constant <code>public static final int DAYS_WEEK = 7</code></li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class StaticFun {
	public static final int TARGET_NUM_HATS = 10;
	private static int countNumMade = 0;
	private int favNum = 0;

	public static void main(String[] args) {
		changeFavNum(42); // ‚ö†Ô∏è non-static function misused
		displayInfo(); 
		favNum = 10; // ‚ö†Ô∏è non-static field
		countNumMade = 9;
	}
	private void changeFavNum(int i) {
		favNum = TARGET_NUM_HATS + i;
		displayInfo();
	}
	private static void displayInfo() {
		System.out.println(&quot;TARGET_NUM_HATS: &quot; + TARGET_NUM_HATS);
		System.out.println(&quot;countNumMade: &quot; + countNumMade);
		System.out.println(&quot;favNum: &quot; + favNum);
	}
}
</code></pre>
<h2 id="static-factory-method">Static Factory Method</h2>
<p>A static method which creates an object is called the static factory method. It is more flexible than constructors and it can be given a descriptive name.</p>
<p>Static Factory Method can be used to solve omitting parameter problems. (Overriding does not help when trying to omit the first parameter. )</p>
<pre><code class="language-java">public static makePizzaFromFile (File file) {
	// Open file and read in values
	// Create new Pizza object
	// Return the Pizza
}
</code></pre>
<h2 id="anonymous-classes-object">Anonymous Classes / Object</h2>
<p>Instance of an unnamed class which is defined on the fly. Useful when you need a short custom class to use just once. For example:</p>
<ul>
<li>Custom sorting</li>
<li>Filtering files in a list</li>
</ul>
<h3 id="anonymous-class">Anonymous Class</h3>
<pre><code class="language-java">FileFilter filter = new FileFilter() { // ‚ö†Ô∏è () is necessary
	@Override
	public boolean accept(File file) {
		return file.getName().endsWith(&quot;.txt&quot;);
	}
}; // ‚ö†Ô∏è ; is necessary
File[] fileList = folder.listFiles(filter);
</code></pre>
<h3 id="anonymous-object">Anonymous Object</h3>
<pre><code class="language-java">File[] fileList = folder.listFiles(new FileFilter(){
	@Override
	public boolean accept(File file) {
		return file.getName().endsWith(&quot;.txt&quot;);
	}
});
</code></pre>
<hr>
<h1 id="ide-configurations">IDE Configurations</h1>
<h2 id="shortcuts-intelli-j">Shortcuts - Intelli J</h2>
<ul>
<li>To run a program for the first time: <strong>Control-Option-R</strong></li>
<li>To run a program the second or more time: <strong>Control-R</strong></li>
<li>Refactoring: <strong>Control-Option-V</strong></li>
<li>Quick Fixes: <strong>Option-Enter</strong></li>
<li>To check required arguments: <strong>Control-P</strong></li>
<li>Generate a constructor_setter_getter: <strong>Alt-Insert</strong></li>
<li>Gets to where a class is defined: <strong>Option-Click</strong></li>
<li>Assisted correction: <strong>Alt-Enter</strong></li>
<li>Duplicate line: <strong>Control-D</strong></li>
<li>Move a line: <strong>Control-Shift-Up/Down</strong></li>
<li>System.out.println(): <strong>‚Äúsout‚Äù-Enter</strong></li>
</ul>
<h2 id="generating-jar-files-and-using-command-lines">Generating .jar files and using command lines*</h2>
<hr>
<h1 id="java-language-features">Java Language Features</h1>
<h2 id="garbage-collection-and-multiple-object-reference">Garbage Collection and Multiple Object Reference</h2>
<p>An object is said to be eligible for GC (garbage collection) iff it is <strong>unreachable</strong>. An object is said to be unreachable iff it doesn‚Äôt contain any reference to it.</p>
<pre><code class="language-java">Integer i = new Integer(4);
// the new Integer object is reachable  via the reference in 'i' 
i = null;
// the Integer object is no longer reachable. 

GreetingsSelf phoneMsg = new GreetingsSelf(&quot;Einstein&quot;); 
// Use the new keyword when an object is being explicitly created for the first time. Java has only dynamic objects. 
// If the new keyword is not used, it will copy a reference to the same object. 
GreetingsSelf emailMsg = phoneMsg;
emailMsg.setName(&quot;Albert&quot;); // Both are set to &quot;Albert&quot;
</code></pre>
<h2 id="dependency-injection">Dependency Injection</h2>
<p>Transferring the task of creating the object to someone else and directly using the dependency is called <strong>dependency injection</strong>.</p>
<p>Ideally Java classes should be as independent as possible from other Java classes. This <strong>increases the possibility of reusing</strong> these classes and to be able to <strong>test them independently from other classes</strong>.</p>
<p>If the Java class <strong>creates an instance of another class via the new operator</strong>, it cannot be used (and tested) independently from this class and this is called a <strong>hard dependency</strong>.</p>
<pre><code class="language-java">public class MyClass {
    private Logger logger;
    public MyClass(Logger logger) {
        this.logger = logger;
        logger.info(&quot;This is a log message.&quot;);
    }
}
</code></pre>
<h3 id="three-types-of-dependency-injection">Three Types of Dependency Injection</h3>
<ol>
<li>Constructor Injection</li>
<li>Setter Injection</li>
<li>Interface Injection</li>
</ol>
<h2 id="pass-by-value-copy">Pass by Value (copy)</h2>
<p>Java uses pass by value.</p>
<ul>
<li>Passing a primitive type passes its value.</li>
<li>Passing an object passes (by value) a reference to the object</li>
</ul>
<p>This means:</p>
<ul>
<li>When passed a primitive type, changes inside a method have no effect outside the method.</li>
<li>When passed an object, you can modify its state.</li>
<li>You cannot change which object the passed parameter points to.</li>
</ul>
<pre><code class="language-java">void changeWhichPizza(Pizza pizza) {
	pizza = new pizza(10); // the original value is not changed, only the copy that used in this function changed
}
</code></pre>
<h2 id="sorting">Sorting</h2>
<p>Java has built-in sorting for collection: arrays, ArrayList etc., and the original list will be mutated (copy, sort, copy):<br>
<code>java.util.Collections.sort(myCars);</code></p>
<h3 id="comparable-interface">Comparable Interface</h3>
<p>Elements in the collection must implement the <code>Comparable</code> (generic) interface. The <code>Comparable</code> interface defines the natural order.</p>
<pre><code class="language-java">class Pen implements Comparable&lt;Pen&gt; {
	String colour;
	int filled;

	@Override
	public int compareTo (Pen other) {
		// Strings are comparable
		return colour.compareTo(other.colour); 
	}
}
</code></pre>
<h3 id="comparator-interface">Comparator Interface</h3>
<p><code>Comparator</code> is used for multiple sort orders in <code>java.util.Collections.sort(list, new PenSortByFilled())</code>.</p>
<ul>
<li>Returns negative integer for	<code>o1 &lt; o2</code></li>
<li>Returns zero integer for		<code>o1 == o2</code></li>
<li>Returns positive integer for	<code>o1 &gt; o2</code></li>
</ul>
<pre><code class="language-java">public static void main (String[] args) {
	...
	Collections.sort(list, new Comparator(){
		@Override
		public int compare (Pen o1, Pen 02) {
			return 01.getFilled() - o2.getFilled();
		}
	};)
}
</code></pre>
<p>Encapsulating an algorithm into a class is called &quot;<strong>Strategy Pattern</strong>&quot;. The algorithm can change without changing the general function itself.</p>
<hr>
<h1 id="input-and-output">Input and Output</h1>
<h2 id="formatted-printing">Formatted Printing</h2>
<h3 id="common-conversion-specifiers">Common Conversion Specifiers</h3>
<p><code>%d</code> - decimal (int)<br>
<code>%x</code> - hexadecimal<br>
<code>%f</code> - float<br>
<code>%s</code> - String<br>
<code>%b</code> - boolean<br>
<code>%n</code> - new line (\n)</p>
<h3 id="formatting-floats-and-columns">Formatting Floats and Columns</h3>
<p><code>%.2f</code> - Round to 2 decimal-point places<br>
<code>%5d</code> <code>%5.2f</code> - Use at least 5 columns (formatted from right margin)<br>
<code>%,d</code> <code>%,10.2f</code> - Print with comma groupings</p>
<h2 id="user-input">User Input</h2>
<p>Java does garbage collection on unused objects, but some objects hold resources. For example, <strong>File, network socket ad input stream</strong>. These objects must be explicitly closed or users will suffer a <strong>resource leak</strong>. However, Scanners created from <code>System.in</code> need not to be closed since it is provided by the OS.</p>
<pre><code class="language-java">import java.util.Scanner;  // Import the Scanner class

class MyClass {
  public static void main(String[] args) {
    Scanner myObj = new Scanner(System.in);  // Create a Scanner object
    System.out.println(&quot;Enter username&quot;);

    String userName = myObj.nextLine();  // Read user input
    System.out.println(&quot;Username is: &quot; + userName);  // Output user input
  }
}
</code></pre>
<h3 id="inputmismatchexception">InputMismatchException</h3>
<pre><code class="language-java">int diameter = 0;

// 1. Using try-catch statements
try {
	diameter = scanner.nextInt();
} catch (InputMismatchException ex) {
	System.out.println(&quot;Int only!&quot;);
}

// 2. Using .hasNextInt()
if (scanner.hasNextInt()) {
	diameter = scanner.nextInt();
} else {
	System.out.println(&quot;Int only!&quot;);
}
</code></pre>
<h2 id="file-methods">File Methods</h2>
<p><code>file.getAbsolutePath()</code>	- Get the path<br>
<code>file.exist()</code>				- Does the file exist<br>
<code>file.length()</code>				- Get it's size in bytes<br>
<code>file.isDirectory()</code>		- Is is a directory<br>
<code>file.listFiles()</code>			- Get all files in the folder<br>
<code>file.listFiles(FileFilter filter)</code></p>
<h3 id="filefilter-interface">FileFilter Interface</h3>
<p>Write a method it can call to ask us for each file if we want to accept it.</p>
<p>Without using anonymous classes:</p>
<pre><code class="language-java">// A trivial class
public class TextFilter implements FileFilter {
	@Override
	public boolean accept(File file) {
		return file.getName().endWith(&quot;.txt&quot;);
	}
}

// Code to interface
FileFilter filter = new TextFilter();
</code></pre>
<h2 id="text-files">Text Files</h2>
<h3 id="opening-files">Opening files:</h3>
<p>Construction: <code>File(filePath)</code><br>
Package: <code>java.io.File</code></p>
<h3 id="reading-files">Reading files</h3>
<p>Construction: <code>Scanner(File)</code><br>
Methods: <code>.hasNextInt(), .nextInt()</code><br>
Package: <code>java.util.Scanner</code><br>
Needs to be closed manually.</p>
<h3 id="writing-files">Writing files</h3>
<p>Construction: <code>PrintWriter(File)</code><br>
Package: <code>java.io.PrintWriter</code><br>
Methods: <code>.println(), .close(), .flush()</code><br>
PrintWriter for the screen:<br>
<code>PrintWriter myWriter = new PrintWriter(System.out);</code></p>
<h3 id="exception">Exception</h3>
<p>Exception type:  <code>FileNotFoundException</code></p>
<pre><code class="language-java">File sourceFile = new File(&quot;C:/dos/run/test.txt&quot;);
try {
	Scanner scanner = new Scanner(sourceFile);
	while (scanner.hasNextLine()) {
		String text = scanner.nextLine();
		System.out.println(&quot;Read:&quot; + text); 
	}
	scanner.close();
} catch (FileNotFoundException e) {
	e.printStackTrace();
}
</code></pre>
<hr>
<h1 id="data-types-and-built-in-classes">Data Types and Built-in Classes</h1>
<h2 id="mutability">Mutability</h2>
<pre><code class="language-java">String msg = &quot;H&quot;;
msg = msg + &quot;i&quot;;
msg += &quot;!&quot;;
// created 3 strings, first 2 for garbage collection
</code></pre>
<p>Java does not support overloaded operators in general, except for + and += on the String class.</p>
<h2 id="strings">Strings</h2>
<p>Strings are stored in Unicode: 2 bytes (16 bits) per character.</p>
<h3 id="indexing">Indexing</h3>
<p><code>char first = msg.charAt(0);</code></p>
<h3 id="methods-on-string">Methods on String</h3>
<pre><code>* `.length()`
* `.contains(...)`
* `.endsWith(...)`
* `.isEmpty()`
* `.replace(...)`
* `.split(...)`
* `.toLowerCase()`
* `.trim()`
* Since Strings are immutable (cannot be changed after being created), all methods return a new String. Values need to be caught. 
</code></pre>
<h3 id="comparing-strings">Comparing Strings</h3>
<p><code>password.equals(&quot;12345&quot;)</code><br>
<code>==</code>  will compares the reference.</p>
<h3 id="read-values-from-strings">Read values from strings</h3>
<pre><code class="language-java">String myInput = &quot;42&quot;;
int theValue = Integer.parseInt(myInput);
</code></pre>
<pre><code>* `Double.parseDouble(...)`
* `Boolean.parseBoolean(...)`
* `Long.parseLong(...)`
* NumberFormatException
	* `int oops = Integer.parseInt(&quot;Oops&quot;);`
</code></pre>
<h3 id="string-literals">String Literals</h3>
<p><strong>String literals</strong> are of the string class.<br>
<code>int length = &quot;Hello&quot;.length();</code></p>
<h2 id="date-javautildate">Date (java.util.Date)</h2>
<p><code>Date.toString()</code> -&gt; <code>Thu Jan 16 13:49:46 PST 2020</code></p>
<h2 id="the-math-class-static">The Math class (static)</h2>
<ul>
<li>.sqrt()</li>
<li>.ceil()</li>
<li>.pow()</li>
<li>.PI</li>
</ul>
<h2 id="type-casting">Type Casting</h2>
<p><code>(double)weightInG</code></p>
<h2 id="type-conversion-3">Type Conversion (3)</h2>
<h3 id="type-promotion-converting-from-a-smaller-type-to-a-larger-one">Type Promotion: Converting from a smaller type to a larger one.</h3>
<p>Automatic Type Promotion:</p>
<pre><code class="language-java">class Test 
{ 
    public static void main(String[] args) 
    { 
        int i = 100;
        // automatic type conversion 
        long l = i;  
        // automatic type conversion 
        float f = l;  
        System.out.println(&quot;Int value &quot;+i); // 100
        System.out.println(&quot;Long value &quot;+l); // 100
        System.out.println(&quot;Float value &quot;+f); // 100.0
    } 
} 
</code></pre>
<h3 id="type-demotion">Type Demotion</h3>
<pre><code class="language-java">int height = (int) 10.99;
float length = (float) 12.0; // by default it uses double
</code></pre>
<h3 id="constants">Constants</h3>
<p><code>final int MAX_LENGTH = 100;</code></p>
<hr>
<h1 id="collections-type">Collections Type</h1>
<h2 id="list-and-arraylist">List and ArrayList</h2>
<p>Collections only store <strong>objects</strong>, not primitive type (store as of <strong>wrapper</strong> classes instead).<br>
* <code>Integer</code>, <code>Long</code>, <code>Double</code>, <code>Character</code></p>
<pre><code class="language-java">values.add(new Double(6));
values.add(new Double(4));
values.add(4); // auto boxing 
java.util.Collections.shuffle(values);
</code></pre>
<pre><code class="language-java">// null reference
ArrayList&lt;Door&gt; doors1;
// Type inference
ArrayList&lt;Door&gt; doors2 = new ArrayList&lt;&gt;();
// Using polymorphism to simplify code
// ArrayList implements the List interface and is backed by an array (fast), and dynamically resize
//--------------------------------------------------------
// CODE TO INTERFACE
//--------------------------------------------------------
// Code to interface makes the code more flexible (can change to LinkedList easily)
List&lt;Door&gt; doors = ArrayList&lt;&gt;(); 

// appending
doors.add(new Door(true, 1000));
heavyDoors.add(door); // taking your reference to one door (the same object)
// indexing for lists
doors.get(0);
doors.get(doors.size() - 1);
// if the list is empty
doors.isEmpty();
</code></pre>
<h2 id="arrays">Arrays</h2>
<pre><code class="language-java">// Fixed size
int[] ages = new int[10];
int size = ages.length;
// Throws exception
int oops = size ages[size];
</code></pre>
<hr>
<h1 id="control-flow">Control Flow</h1>
<h2 id="enhanced-for-loop">Enhanced for loop</h2>
<p>Can help avoid <strong>indexOutOfBound</strong> (Java will throws an exception).</p>
<pre><code class="language-java">// implement the Iterable&lt;&gt; interface
public class DoorManager implements Iterable&lt;Door&gt; {
	//Type inference
	private List&lt;Door&gt; doors = new ArrayList&lt;&gt;(); 

	public void add(Door door){
		doors.add(door);
	}
	// Class 'DoorManager' must either be declared abstract or implemented abstract method 'iterator()' in 'Iterable'
	public iterator&lt;Door&gt; iterator(){
		return this.doors.iterator();
		// Lists of Door return iterator of Door
	}
}

// Prerequisite: iterable 
for (Door door : doors) {
	System.out.println(&quot;Door = &quot; + door);
}
</code></pre>
<h2 id="switch-statement">Switch Statement</h2>
<pre><code class="language-java">switch(choice) {
	case 1:
		System.out.println(&quot;You entered a one!&quot;);
		System.out.println(&quot;Thank you!&quot;);
	case 2:
		System.out.println(&quot;You entered a two!&quot;);
		System.out.println(&quot;Amazing!&quot;);
	case 3:
		System.out.println(&quot;You entered a three!&quot;);
		System.out.println(&quot;Good!&quot;);
	default:
		System.out.println(&quot;You entered a number!&quot;);
		System.out.println(&quot;lol!&quot;);
}
</code></pre>
<hr>
<h1 id="coding-style">Coding Style</h1>
<h2 id="the-one-name-principle">The One Name Principle</h2>
<p>Use the <strong>this</strong> keyword to reference the current object for clarity. Java will do auto dereference when an object is not needed.<br>
Name field and constructor parameters the same.</p>
<h2 id="classes-and-visibility">Classes and Visibility</h2>
<ul>
<li>All <strong>fields</strong> (instance data) are set to <strong>private</strong>. Public methods can call private methods.</li>
<li>If you want something to be unchangeable, you may provide no setters to prevent invalid data.
<ul>
<li>Easier for maintainance</li>
</ul>
</li>
<li>Using constant when applicable (the <strong>final</strong> keyword, UPPERCASE)
<ul>
<li>Final Variable -&gt; To create constant variables</li>
<li>Final Methods -&gt; Prevent Method Overriding</li>
<li>Final Classes -&gt; Prevent Inheritance</li>
</ul>
</li>
<li>Use the <strong>static</strong> keyword <strong>only when sharing is intended</strong></li>
<li><code>/src/main/java/‚Ä¶</code></li>
<li>Return a string instead of printing it to console directly.</li>
<li>Primitive Types are not objects. Everything else is an object reference.</li>
</ul>
<h2 id="javadoc-documentation">JavaDoc (Documentation)</h2>
<p>Used for classes (the purpose of a class etc.) and sometimes for API methods. Don't comment functions / methods, instead, use better naming.</p>
<pre><code class="language-java">/**
	* @author
	* @param a Length of the first side; must be &gt;= 0. 
	*/
</code></pre>
<h2 id="package-model-view">Package &amp; Model-View</h2>
<ul>
<li>Create a package: <strong>src / main / java -&gt; new -&gt; Package</strong></li>
<li>Example naming: <code>ca.doordemo.model</code></li>
<li>Package is a group of classes that's related to each other. On top of each class within a package, there will be a statement similar to <code>package ca.doordemo.model</code> claiming that the class belongs to which package.</li>
<li>Do not use any <code>System.out.println()</code> in model to increase reusability. (On some platform <code>System.out.println()</code> has no meaning. )</li>
</ul>
<pre><code class="language-java">import ca.doordemo.model.DoorManager;
import ca.doordemo.ui.DoorTextUI;

public class Main {
	// Create model
	DoorManager manager = new DoorManager();
	
	// Create UI
	DoorTextUI ui = new DoorTextUI(Manager);

	// Launch
	ui.show();
}
</code></pre>
<hr>
<h1 id="others">Others</h1>
<ul>
<li><code>boolean</code> is set to false by default.</li>
<li>Providing constructors will delete the default constructor set up by Java</li>
<li><strong>Concatenating</strong> a string and an instance will automatically call the .toString() method.</li>
<li>Everything in Java is a reference, every class is a subclass of the Object class.</li>
<li>println -&gt; prints with <strong>linefeed</strong></li>
<li>char -&gt; Unicode</li>
<li>boolean has only true or false to prevent the &quot;==&quot; mistyping issues.</li>
<li>Divide by 0.0 -&gt; Infinity</li>
</ul>
<hr>
<h1 id="exceptions-debugging">Exceptions &amp; Debugging</h1>
<h2 id="exceptions">Exceptions</h2>
<p>Catch the error so that we don't have to shut down the whole program.</p>
<pre><code class="language-java">import java.util.*; // importing everything

public class sample {
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int x = 1;

		do{
			try{
				System.out.println(&quot;Enter first num: &quot;);
				int n1 = input.nextInt();
				System.out.println(&quot;Enter second num: &quot;);
				int n2 = input.nextInt();
				// where the error might occur
				int sum = n1 / n2; 
				System.out.println(sum);
				// runs successfully only without errors
				x = 2; 
			} catch (Exception e) { // any error
				System.out.println(&quot;You can't do this. &quot;);
			}
		} while(x == 1);
	}
}
</code></pre>
<p>Another sample:<br>
<code>throw new RuntimeException(&quot;Busted!&quot;)</code></p>
<h2 id="tostring">.toString()</h2>
<p>All Java objects have a toString() method since all classes inherit from Object. It returns a String object which used for debugging instead of formatted screen / file output.</p>
<pre><code class="language-java">@Override // To prevent typo
public String toString() {
	return getClass.getName() // returns the name of object
		+ &quot; [daField1 = &quot; + daField1
		+ &quot;, daField2 = &quot; + daField2 + &quot;]&quot;;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Algorithms - Week 3~4]]></title>
        <id>https://jenkinsxu.github.io/post/algorithms-week-3~4/</id>
        <link href="https://jenkinsxu.github.io/post/algorithms-week-3~4/">
        </link>
        <updated>2020-01-22T01:08:10.000Z</updated>
        <content type="html"><![CDATA[<p>For simplicity, we will for now ignore the so-called &quot;Carmichael Numbers&quot;. Theses are extremely rare composite number that will pass this test (1.7) for all a with gcd(a, N) = 1.</p>
<p>Any non-Carmichael composite number N must fail Fermat's test at least some value of a.</p>
<p>We can show that N fails Fermat's test for at least half the possible values of a.</p>
<p><strong>Lemma</strong>: If a^(N-1) !‚â° 1 mod N for some a with gcd(a, N) = 1, then it must hold for at least half the choice of a &lt; N.<br>
<strong>Note</strong>: This lemma is not helpful for Carmichael numbers.<br>
<strong>Proof</strong>:<br>
Fix a such that a^(N-1) !‚â° 1 (mod N)<br>
‚àÄ b &lt; N that pass Fermat's test with respect to N (i.e b^(N-1) ‚â° 1 mod N) has a twin a<em>b, that fails the test!<br>
<code>(a*b) ^ (N-1) ‚â° a^(N-1) * b^(N-1) ‚â° a^(N-1) !‚â° 1 mod N</code><br>
All a * b for fixed a but different b are distinct. (<strong>HW</strong>)<br>
The one-to-one function f: f(b) = a</em>b shows that at least as many elements fail the test as pass it.</p>
<p>Algorithm 1.7 therefore has the following probabilistic behavior<br>
P (1.7 returns &quot;yes&quot; when N is prime) = 1<br>
P (1.7 returns &quot;yes&quot; when N is composite) ‚â§ 1/2<br>
This error rate can be reduced by randomly picking different a's many times (k times).</p>
<h3 id="algorithm-18">Algorithm 1.8</h3>
<p><strong>function primality(N)</strong><br>
<strong>Input</strong>: N ‚àà N+<br>
<strong>Output</strong>: yes/no<br>
Pick positive integers a1,a2,...,ak at random</p>
<pre><code>if ai^(N-1) ‚â° 1 (mod N) for all i = 1,2,...,k
	return yes
else
	return no
</code></pre>
<p>Algorithm 1.8 returns &quot;yes&quot; when N is composite ‚â§ 1/(2^k) [minuscule for k = 100]</p>
<h3 id="carmichael-numbers">Carmichael Numbers</h3>
<p>Smallest Carmichael number: 561<br>
561 = 3 * 11 * 17, i.e. not prime yet<br>
‚àÄ a relative prime to 561: a^561 ‚â° 1 (mod 561), i.e. it fools the Fermat test for such bases.</p>
<p>Now, guessing bases is no better than randomly guessing factors.</p>
<p>Rabin and Miller devised an algorithm for primality testing that also deals with Carmichael numbers (see P28).</p>
<h2 id="generating-random-primes">Generating Random Primes</h2>
<p>For our crypto-system we need a fast way to generate random primes that are several hundred bits long.<br>
Good news! Prime numbers are abundant.</p>
<h3 id="lagranges-prime-number-theorem">Lagrange's Prime Number Theorem</h3>
<p>Let # (x) be the number of primes ‚â§ x.<br>
Then # (x) ‚âà x / ( ln(x) )<br>
or more precisely lim x -&gt; ‚àû : # (x) / (x / ln(x) ) = 1</p>
<h3 id="generate-a-random-prime-of-length-n">Generate a random prime of length n:</h3>
<ol>
<li>Pick a random n-bit number</li>
<li>Run a primality test on N</li>
<li>If it passes test output N, else goto <strong>1.</strong><br>
This runs on average O(n) steps.</li>
</ol>
<h2 id="some-notes-on-randomized-algorithms">Some notes on Randomized Algorithms</h2>
<p>Two varieties:</p>
<ol>
<li>&quot;Monte Carlo Algorithms&quot;</li>
</ol>
<ul>
<li>Always run fast</li>
<li>Output has a small chance being incorrect<br>
<strong>Example</strong>: Primality Test</li>
</ul>
<ol start="2">
<li>&quot;Las Vegas Algorithms&quot;</li>
</ol>
<ul>
<li>Always output the correct answer</li>
<li>Only guarantee a short run time with high probability<br>
<strong>Example</strong>: randomized algorithms for sorting</li>
</ul>
<h1 id="section-14-cryptography">Section 1.4 Cryptography</h1>
<h2 id="rivestshamiradleman-rsa-crypto-system">Rivest‚ÄìShamir‚ÄìAdleman (RSA) crypto-system</h2>
<p>Exploits the wide gulf between polynomial time tasks (modular exponentiation, gcd, primality testing) and the intractability of others (factoring).<br>
<img src="Photo%20Jan%2021,%202020%20at%2035329%20PM.jpg" alt="" loading="lazy"><br>
More generally:<br>
<img src="Photo%20Jan%2021,%202020%20at%2035922%20PM.jpg" alt="" loading="lazy"></p>
<h2 id="different-cryptography-protocols">Different Cryptography Protocols</h2>
<h3 id="private-key-protocols">Private-key protocols</h3>
<ul>
<li>Done for millennia.</li>
<li>Both parties (A, B) need to meet beforehand to chose a secret code book.</li>
<li>Code book is used to encrypt and decrypt all messages between them.</li>
<li>Eve's only hope is to collect many encrypted messages and hope to used those to figure out the code book.</li>
</ul>
<h3 id="public-key-protocols">Public-key protocols</h3>
<ul>
<li>RSA is public key</li>
<li>No meeting between Alice and Bob is necessary</li>
<li>e(.) is publicly available, Alice can use it to digitally lock her message</li>
<li>Only Bob knows the digital key d(.) to quickly unlock e(.)</li>
<li>Both Alice and Bob need only perform simple calculations to lock and unlock messages</li>
<li>However, unlocking the message without the key should exceed the capability of all supercomputers combined</li>
<li>This enables secure Web-commerce, i.e. sending encrypted Credit Card numbers over the Internet</li>
</ul>
<hr>
<p>Private-key schemes: one time pad and AES<br>
x: message, e(x) encrypted message<br>
In order to decode e(x), it must be an invertible function. It must be a <strong>bijection</strong>.<br>
The inverse of e(x) is d(x), i.e. d(x) = e^(-1)(x)</p>
<p><strong>One-time Pad</strong>:<br>
Alice and Bob secretly agree on binary string r with |r| = |x| = n. x is the secret string to be sent by Alice later.<br>
Alice's encryption function is:<br>
<img src="Photo%20Jan%2021,%202020%20at%2041102%20PM.jpg" alt="" loading="lazy"></p>
<ul>
<li>e_r is a bijection from n-bit strings to n-bit strings (<strong>HW</strong>: verify this)</li>
<li>e_r = e_r^(-1) (e_r is its own inverse) - please verify</li>
<li>e_r ( e_r(x) ) = (x ‚äï r) ‚äï r = x ‚äï 0 = x</li>
</ul>
<p>Bob can use e_r(x) to decode message. For r to be secure, chose r at random (coin flipping each bit). Eve intercepts y = e_(x), she gets no information about x, since all possibilities for x are equally likely.</p>
<p>Downsides of &quot;One-time Pad&quot;</p>
<ul>
<li>Authentication of Alice</li>
<li>Meeting for key exchange</li>
<li>|r| = |x| key length is terrible</li>
<li>Needs to be discarded after each use</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Algorithms - Week 2]]></title>
        <id>https://jenkinsxu.github.io/post/algorithms-week-2/</id>
        <link href="https://jenkinsxu.github.io/post/algorithms-week-2/">
        </link>
        <updated>2020-01-18T02:30:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="modular-division">Modular Division</h2>
<ul>
<li>Dividing by a != 0 is the same as multiplying by a^(-1) = 1 / a (the inverse of a). Here we assume rational numbers.</li>
<li>In modular arithmetic:
<ul>
<li>‚Äúx is said to be the multiplicative inverse of a modulo N if a*x ‚â° 1 (mod N)‚Äù</li>
</ul>
</li>
<li>We call such an x the inverse of a and denote it a^(-1)
<ul>
<li>Now modular division become the problem of computing x = a^(-1) , given a and N<br>
<strong>Example:</strong><br>
<strong>Q:</strong> What is 11^(-1) mod 25 (i.e. The inverse of 11 mod 25)<br>
‚áí we use the extended Euclidian Algorithm For gcd (25, 11)<br>
‚áí 15 * 25 - 34 * 11 = 1, Now reduce both sides mod 25<br>
‚áí 0 - 34 * 11 ‚â§ 1 (mod 25)<br>
16 * 11‚â°1<br>
‚áí 16 is the inverse of 11 (mod 25)<br>
<strong>Q:</strong> Does the inverse a^(-1) always exist?<br>
<strong>A:</strong> No, only when gcd (a, N) = 1, i.e. a and N are relative prime.<br>
We know that ax + Ny = 1 (via extended Euclidian Algorithm) &lt;‚áí ax ‚â° 1 (mod N) ‚áí x is a‚Äôs inverse mod N. However, if gcd (a, N) &gt; 1, then no inverse of a mod N exists. (convince yourself that this is true, page 23 is helpful)</li>
</ul>
</li>
</ul>
<h3 id="modular-division-theorem">Modular Division Theorem</h3>
<p>For any a mod N, a has a multiplicative inverse mod N &lt;‚áí gcd (a, N) = 1.<br>
When this inverse exists, it can be computed in O(n¬≥) time by running the extended Euclid algorithm for gcd(a, N) where n = # of bits for N.</p>
<h3 id="primality-testing">Primality Testing</h3>
<p><strong>Q:</strong> Can we decide whether integer x is prime without factoring?<br>
<strong>A:</strong> Yes, to some extend.<br>
<strong>Goal:</strong>	input N<br>
output yes (if N is prime)<br>
output no (if N is composite)<br>
With a minuscule rate of error.<br>
<strong>Tools Fermat‚Äôs little theorem:</strong><br>
If p is prime, then ‚àÄa: 1 ‚â§ a ‚â§ p: a^(p-1) ‚â° 1 (mod p) (<strong>HW</strong>: Proof - textbook)</p>
<p><strong>Example:</strong><br>
p = 7 (p is prime)<br>
1^6 ‚â° 2^6 ‚â° 3^6 ‚â° 4^6 ‚â° 5^6 ‚â° 1 mod 7</p>
<p>p = 8 (p is composite)<br>
2^(p-1) = 2^4 = 128 and 128 !‚â° 1 mod 8</p>
<p>However, Fermat‚Äôs little theorem is not an ‚Äúif and only if‚Äù statement. Therefore some composite numbers will pass it!<br>
341 = 11 * 13  is not prime, yet 2^340 ‚â° mod 341, so 341 passes the Fermat‚Äôs test, but is composite.<br>
Here 341 is called a <strong>Fermat Pseudoprime</strong> and a = 2 is called a <strong>Fermat Liar</strong>.</p>
<p><strong>Hope:</strong> For composite N, most values of a will fail the test.<br>
‚áí simple algorithm for testing primality</p>
<p>‚Ä¶</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Algorithms - Week 1]]></title>
        <id>https://jenkinsxu.github.io/post/algorithms-week-1/</id>
        <link href="https://jenkinsxu.github.io/post/algorithms-week-1/">
        </link>
        <updated>2020-01-14T11:11:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="fib">fib()</h1>
<h3 id="the-formula">The formula</h3>
<h3 id="facts">Facts</h3>
<ul>
<li>Grow as fast as 2^n</li>
<li>fib(100) is 21 digits long</li>
<li>In general T(n) = 2^(0.694n)</li>
</ul>
<p><strong>Q: What is the precise value of F100 or F200</strong><br>
A exponential algorithm:</p>
<pre><code class="language-python">func fib(n):
	if n = 0: return 0
	if n = 1: return 1
	return fib(n - 1) + fib(n - 2)
</code></pre>
<h3 id="any-algorithm-implies-3-questions">Any algorithm implies 3 questions</h3>
<ol>
<li>Is it correct?</li>
<li>How much time does it take as a function of input size n?</li>
<li>Can we do better?</li>
</ol>
<ul>
<li>Often, space is an important consideration too.</li>
</ul>
<h3 id="answers">Answers</h3>
<ol>
<li>Yes, by definition</li>
<li>Let T(n) be the # of steps needed to compute fib(n)
<ul>
<li>T(n) ‚â§ 2 for n ‚â§ 1</li>
<li>T(n) = T(n-1) + T(n-2) + 3 for n &gt; 1<br>
**Observation:**T(n) ‚â• F(n)<br>
<strong>Conclusion:</strong><br>
The running time grows as fast as the fibonacci numbers.<br>
T(n) is exponential in n, so very impractical (except for very small n's)<br>
<strong>Q:</strong> How bad?<br>
<strong>A:</strong><br>
T(200) ‚â• F100 ‚â• 2^138 elementary computing steps.<br>
With 40 trillion operations per seconds (NEC Earth simulator):</li>
<li>fib(200) taken about 2 ^ 92 seconds</li>
<li>Longer than the remaining life of our sun<br>
Even Moore's Law doesn't help.</li>
<li>Computers get 1.6 times faster every year or twice as fast every 18 months.</li>
<li>fib(n) taken roughly 2^0.694n (or 1.6^n)
<ul>
<li>It takes 1.6 times longer to compute Fn+1 than Fn</li>
<li>If we can compute F100 with this years technology, then we can compute F101 with next year's technology. (One more Fibonacci number per year. )</li>
</ul>
</li>
</ul>
</li>
<li>A polynomial algorithm<br>
<strong>Q:</strong> Why is fib(n) so slow?<br>
<strong>A:</strong>  repeated calls<br>
<strong>More sensible approach:</strong> store intermediate results (a form of dynamic programming)</li>
</ol>
<pre><code class="language-swift">func fib(n) {
	if n = 0 {
		return 0
	}
	f = [0, 1]
	for i in 2...n {
		f.append(f[i-1] + f[i-2])	
	}
	return f[n]
}
</code></pre>
<ul>
<li>Correct by definition</li>
<li>Inner loop gets executed n-1 times (one addition)
<ul>
<li>fib(n) is linear in n</li>
<li>we are now down from exponential to linear time</li>
<li>One outstanding issue: fib(n) has to add increasingly larger integers
<ul>
<li>issues around precision or time</li>
<li>it takes more time to add F199 and F200 than e.g. F3 and F4
<ul>
<li>fib(n) roughly performed Fn additions -&gt; # of basic steps is roughly proportional to n*Fn (still exponential)</li>
</ul>
</li>
</ul>
</li>
<li>
<h1 id="of-basic-steps-is-roughly-proportional-to-n2-still-polynomial-hw-why-bits-level">of basic steps is roughly proportional to <strong>n^2</strong> (still polynomial) <strong>[HW: Why? - bits level]</strong></h1>
</li>
</ul>
</li>
</ul>
<h1 id="the-big-o-notation">The Big-O Notation</h1>
<ul>
<li>
<p>Need to be precise, but not overly detailed</p>
</li>
<li>
<p>Want to be <strong>machine and architecture independant</strong></p>
</li>
<li>
<p>Further simplification</p>
</li>
<li>
<p>can be viewed as the analog of the relation ‚äÜ</p>
</li>
<li>
<p>we can also define the analogs of ‚â• and = as follows</p>
<ul>
<li>f = Œ©(g) means g = O(f)</li>
<li>f = Œò(g) means f = O(g) and f = Œ©(g)</li>
</ul>
</li>
</ul>
<h1 id="algorithms-with-numbers">Algorithms with numbers</h1>
<h2 id="factoring">Factoring</h2>
<p>Express N as product of its prime factors.</p>
<ul>
<li>Factoring is hard. Exponential in he number of bits of N.</li>
</ul>
<h2 id="primality">Primality</h2>
<p>Is N a prime?</p>
<ul>
<li>Primality testing is very easy!</li>
</ul>
<p>As we shall see, the above 2 problems lie at the heart of <strong>secure encrypted communication</strong>.</p>
<p>First things first: Need for algorithms for basic arithmetic.</p>
<h3 id="basic-grade-school-addition">Basic (grade school) addition</h3>
<ul>
<li>Works because the sum of any 3 single digit number is at most 2 digits long (this holds for all bases b ‚â• 2)
<ul>
<li>Example:</li>
</ul>
</li>
</ul>
<pre><code>	110101 
+	100011
---------
1 011000
</code></pre>
<p><strong>Q:</strong> How fast is this?<br>
<strong>A:</strong> 2n bit number can be added in n + 1 steps, so about c0 + c1*n ‚áí O(n).<br>
<strong>Q:</strong> Can we do better?<br>
<strong>A:</strong> At the minimum we must read 2 n-bit numbers and write down the answer. Even that requires n steps. ‚áí it is <strong>optimal</strong>. (Up to multiplicative constants c0 and c1)</p>
<h3 id="multiplication">Multiplication</h3>
<ul>
<li>The grade school algorithm</li>
<li>The Al-Khwarizmi Multiplication</li>
</ul>
<pre><code>11*13 table
div2, floor()		*2
11					13
5					26
2					52 (strike out)
1					104
</code></pre>
<pre><code>* strike out all rows where x is even
* then add column 2
</code></pre>
<p><strong>Q:</strong> How does this relate to the binary grade school multiplication algorithm?<br>
<strong>A:</strong> The second algorithm is essentially the same as the binary multiplication. We are adding multiples of 13 by powers of 2 as before.<br>
As before:</p>
<pre><code>2^0 * 13 = 13
2^1 * 13 = 26
2^2 * 13 = 104	‚àë = 143
// See text for a third alternative of multiplication
// All 3 versions of multiplication require O(n¬≤) if n = # of bits. 
// We can do better! 
</code></pre>
<h3 id="division">Division</h3>
<p>To divide integer x by integer y ‚â† 0 means to fine integer q and r &lt; y such that x = q(quotient) * y + r(remainder)</p>
<ul>
<li>Standard division (see Fig. 1.2. in text) takes quadratic time.</li>
</ul>
<h1 id="modular-arithmetic">Modular Arithmetic</h1>
<p>Modular arithmetic is a system for dealing with restricted ranges of integers.<br>
<code>x modulo N -&gt; remainder when x is divided by N</code><br>
Ex. 	17 modulo 4 = 1<br>
21 modulo 4 = 1<br>
We say that 17 and 21 are congruent modulo 4. Notation:</p>
<pre><code>a ‚â° b (mod n)
Clock with 60 minutes: -1 ‚â° 59 (mod 60)
</code></pre>
<ul>
<li>Modular arithmetic can be thought of as limiting integers to a specific range of [0, 1, ... , N-1] with &quot;wrap-around&quot;.</li>
<li>Another interpretation is that it deals with all integer, but divides them into N equivalence classes.</li>
</ul>
<pre><code>	...	-9	-6	-3	[0]	3	6	...
{	...	-8	-5	-2	[1]	4	7	...	} 3 equivalent classes mod 3
	...	-7	-4	-1	[2]	5	8	...
</code></pre>
<h3 id="laws-in-modular-arithmetic">Laws in Modular Arithmetic</h3>
<ul>
<li>Substitution Law<br>
If 		x ‚â° x' (mod N) and y ‚â° y' (mod N)<br>
then:	x + y ‚â° x' + y' (mod N) and<br>
x * y ‚â° x' * y' (mod N)</li>
<li>Commutative, Associative, Distributive Laws (etc.) also hold (<strong>HW</strong>)</li>
<li>Can do reduction during calcualtion<br>
2^345 ‚â° (2<sup>5)</sup>69 ‚â° 32^69 ‚â° 1^69 ‚â° 1	(mod 31)  31 = (2^5 - 1)<br>
(because 31‚â° 1 mod 31)</li>
</ul>
<h3 id="addition-mod-n">Addition (mod N)</h3>
<p>x + y (mod N)<br>
x and y are in the range 0 to N-1 ‚áí x + y ‚àà [0, ... , 2(N-1)]<br>
if x + y &gt; N-1, simply <strong>subtract N</strong> to reduce mod N<br>
‚áí 1 addition, possibly 1 subtraction of numbers ‚â§ 2N<br>
‚áí Run time is O(n), where n = ceil(logN) (# of bits)</p>
<h3 id="multiplication-mod-n">Multiplication (mod N)</h3>
<ul>
<li>product is ‚â§ (N-1)¬≤, at most 2n bits -&gt; since log(N-1)¬≤ = 2*log(N-1) ‚â§ 2n
<ul>
<li>regular multiplication: x*y -&gt; O(n¬≤)</li>
<li>reduce mod N</li>
</ul>
</li>
<li>Use division algorithm O(n¬≤) to get the remainder<br>
‚áí O(n¬≤) for modular multiplication</li>
</ul>
<h3 id="division-2">Division</h3>
<ul>
<li>Not quite so straight forward</li>
<li>Can be managed in O(n¬≥) time
<ul>
<li>This is more expensive than regular integer division that was O(n¬≤)</li>
</ul>
</li>
</ul>
<h3 id="modular-exponentiation">Modular Exponentiation</h3>
<p>Goal: Build a crypto-system</p>
<ul>
<li>We need to compute x^y mod N, where x, y and N are several 100 bits long.</li>
<li>x^y is huge even if x and y are only 20-bit numbers.<br>
‚áí x^y is at least (2<sup>19)</sup>(2^19) or about 10,000,000 bits long.</li>
</ul>
<hr>
<p>We could just repeatedly multiply by x modulo y</p>
<pre><code>x		mod N
x¬≤		mod N
x¬≥		mod N
...
x^y	mod N 
</code></pre>
<p>All numbers are &lt; N, but we need to perform y-1 multiplications!<br>
If y has 500 bits ‚áí y - 1 ‚âà 2^500 multiplications!<br>
‚áí clearly exponential in the size of y.</p>
<p><strong>Q:</strong> Can we do better?<br>
<strong>A:</strong> Yes! Square repeatedly modulo N</p>
<pre><code>	 x 	mod N 
	 x¬≤	mod N
	 ...
	 x^2^( ceil( log y ) ) mod N
</code></pre>
<ul>
<li>Each takes O(log¬≤N) time
<ul>
<li>numbers are &lt; N</li>
<li>have &lt; logN bits<br>
‚áí now only log y multiplications</li>
</ul>
</li>
<li>Now, we have all x<sup>(2</sup>i)  (1 ‚â§ i ‚â§ ceil( log y ) )</li>
<li>To determine x^y mod N proceed as follows:</li>
</ul>
<pre><code>x^25 ‚â° x^11001 	‚â° x^10000 * x^1000 * x^1
					‚â° x^16 * x^8 * x 	mod N (look up in table)
</code></pre>
<hr>
<p><strong>Alternate Formulation</strong><br>
Recursive Algorithm (Fig. 1.4)</p>
<pre><code>x^y
	= (x ^ ceil(y / 2) ) ¬≤ if y is even
	= x * (x ^ ( x^(y / 2) ) ) if y is odd
execute this mod N. 
</code></pre>
<ul>
<li>Recursive multiplication used repeated doubling</li>
<li>Recursive exponentiation uses repeated squaring<br>
‚áí n recursive calls (O(n)), multiply n-bit numbers (O(n¬≤))<br>
‚áí O(n¬≥) for modular exponentiation.</li>
</ul>
<h2 id="division-and-mod-n-need-gcd-and-euclids-algorithm">Division and mod N - Need GCD and Euclids Algorithm</h2>
<ul>
<li>gcd(a, b) is the largest integer d that divides both a and b</li>
<li>One approach to compute gcd: factor a and b, then multiply together their common factors:<br>
<strong>Example:</strong></li>
</ul>
<pre><code>1035	= 3¬≤ * 5 * 23 
759	= 3 * 11 * 23
Common factors: 3 and 23
‚áí 3 * 32 = 69 is the gcd of 1035 and 759
</code></pre>
<p><strong>But:</strong> Factoring is hard!</p>
<p><strong>Solution:</strong> Euclid's Algorithm<br>
* Based on the following rule: If x and y are positive integers with x ‚â• y, then <strong>gcd(x, y)  = gcd(x mod y, y)</strong><br>
<strong>Proof:</strong> Enough to show the simpler rule gcd(x, y)  = gcd(x-y, y).<br>
* Any integer that divides both x and y must also divide x-y, so gcd(x, y) ‚â§ gcd(x-y, y).<br>
* Likewise, any integer that divides both x-y and y, must  also divide x, so gcd(x-y, y) ‚â§ gcd(x, y)<br>
‚áí gcd(x, y) = gcd(x-y, y)</p>
<hr>
<p><strong>Euclid's algorithm for finding gcd(a, b)</strong><br>
function Euclid(a, b)<br>
Input: a, b ‚àà H+ with a ‚â• b ‚â• 0<br>
Output: 		gcd(a, b)<br>
if b = 0: return a mod b<br>
Time: After any 2 consecutive rounds, both argument a and b, are the the vast least halved in value, i, e. t their length decreases by at least one bit.<br>
* the base case can be reached within 2n recursive call<br>
* Each call involves O(n¬≤) division<br>
* total time is O(n¬≥)<br>
<strong>HW:</strong> Think about the details. See P.21 for more info.</p>
<hr>
<p><strong>Extension to Euclid's Algorithm</strong><br>
* The gcd(a, b) is the <strong>smallest</strong> positive integer that can be written s a linear combination of a and b.<br>
‚áí d = gcd(a, b) ‚â° ax+ by (linear combination) for some integer x and y. (And d must be <strong>minimal</strong>.)</p>
<p>Textbook uses a slightly different approach.<br>
<strong>Q:</strong> What is different?<br>
<strong>A:</strong> We can extend the Euclidian Algorithm to compute the coefficients for the linear combination.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java Programming: Week 1-2]]></title>
        <id>https://jenkinsxu.github.io/post/java-programming-week-1-2/</id>
        <link href="https://jenkinsxu.github.io/post/java-programming-week-1-2/">
        </link>
        <updated>2020-01-13T20:22:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="basic-java">Basic Java</h2>
<hr>
<h3 id="classes-in-java">Classes in Java</h3>
<pre><code class="language-java">// Can have nested classes, but no more than one full class in  a file
public class HelloWorld {
	public static void main(String[] arug) {
		// static: excuse it without instantiating the object
		System.out.println(&quot;Hello, world.&quot;);
	}
	// no linking errors when multiple main()'s in different classes
}
</code></pre>
<h3 id="shortcuts">Shortcuts</h3>
<ul>
<li>To run a program for the first time: <strong>Control-Option-R</strong></li>
<li>To run a program the second or more time: <strong>Control-R</strong></li>
<li>Refactoring: <strong>Control-Alt-V</strong></li>
<li>Quick Fixes: <strong>Option-Enter</strong></li>
<li>To check required arguments: <strong>Control-P</strong></li>
<li>Generate a constructor_setter_getter: <strong>Alt-Insert</strong></li>
<li>Gets to where a class is defined: <strong>Option-Click</strong></li>
<li>Assisted correction: <strong>Alt-Enter</strong></li>
<li>Duplicate line: <strong>Control-D</strong></li>
<li>Move a line: <strong>Control-Shift-Up/Down</strong></li>
<li>System.out.println(): <strong>‚Äúsout‚Äù-Enter</strong></li>
</ul>
<h3 id="the-math-class-static">The Math class (static)</h3>
<ul>
<li>.sqrt()</li>
<li>.ceil()</li>
<li>.pow()</li>
<li>.PI</li>
</ul>
<h3 id="garbage-collection-and-multiple-object-reference">Garbage Collection and Multiple Object Reference</h3>
<p>An object is said to be eligible for GC (garbage collection) iff it is <strong>unreachable</strong>. An object is said to be unreachable iff it doesn‚Äôt contain any reference to it.</p>
<pre><code class="language-java">Integer i = new Integer(4);
// the new Integer object is reachable  via the reference in 'i' 
i = null;
// the Integer object is no longer reachable. 

GreetingsSelf phoneMsg = new GreetingsSelf(&quot;Einstein&quot;); 
//Use the new keyword when an object is being explicitly created for the first time. Java has only dynamic objects. If the new keyword is not used, it will copy a reference to the same object. 
GreetingsSelf emailMsg = phoneMsg;
emailMsg.setName(&quot;Albert&quot;); // Both are set to &quot;Albert&quot;
</code></pre>
<h3 id="automatic-type-promotion">Automatic Type Promotion</h3>
<pre><code class="language-java">class Test 
{ 
    public static void main(String[] args) 
    { 
        int i = 100;
        // automatic type conversion 
        long l = i;  
        // automatic type conversion 
        float f = l;  
        System.out.println(&quot;Int value &quot;+i); // 100
        System.out.println(&quot;Long value &quot;+l); // 100
        System.out.println(&quot;Float value &quot;+f); // 100.0
    } 
} 
</code></pre>
<p><code>(double)height / width</code></p>
<h3 id="type-casting">Type Casting</h3>
<p><code>(double)weightInG</code></p>
<h3 id="lists">Lists</h3>
<pre><code class="language-java">// null reference
ArrayList&lt;Door&gt; doors1;
// Type inference
ArrayList&lt;Door&gt; doors2 = new ArrayList&lt;&gt;();
// Using polymorphism to simplify code
List&lt;Door&gt; doors = ArrayList&lt;&gt;(); 

// appending
doors.add(new Door(true, 1000));
heavyDoors.add(door); // taking your reference to one door (the same object)
// indexing
doors.get(0);
doors.get(doors.size() - 1);
// if the door is empty
doors.isEmpty();
</code></pre>
<h3 id="interface-empty-bodies">Interface (&quot;empty bodies&quot;)</h3>
<pre><code class="language-java">interface Animal {
	public void animalSound();
	public void sleep();
}

class Pig implements Animal {
	public void animalSound() {
		System.out.println(&quot;wee wee&quot;);
	}
	public static void sleep() {
		System.out.println(&quot;Zzz&quot;);
	}
}
</code></pre>
<h3 id="generic-classes">Generic Classes</h3>
<pre><code class="language-java">public class GenericsType&lt;T&gt; {

	private T t;
	
	public T get(){
		return this.t;
	}
	
	public void set(T t1){
		this.t=t1;
	}
	
	public static void main(String args[]){
	}
}
</code></pre>
<h3 id="enhanced-for-loop">Enhanced for loop</h3>
<pre><code class="language-java">// implement the Iterable&lt;&gt; interface
public class DoorManager implements Iterable&lt;Door&gt; {
	//Type inference
	private List&lt;Door&gt; doors = new ArrayList&lt;&gt;(); 

	public void add(Door door){
		doors.add(door);
	}
	// Class 'DoorManager' must either be declared abstract or implemented abstract method 'iterator()' in 'Iterable'
	public iterator&lt;Door&gt; iterator(){
		return this.doors.iterator();
		// Lists of Door return iterator of Door
	}
}

// Prerequisite: iterable 
for (Door door : doors) {
	System.out.println(&quot;Door = &quot; + door);
}
</code></pre>
<h3 id="dependency-injection">Dependency Injection</h3>
<p>Transferring the task of creating the object to someone else and directly using the dependency is called <strong>dependency injection</strong>.</p>
<p>Ideally Java classes should be as independent as possible from other Java classes. This <strong>increases the possibility of reusing</strong> these classes and to be able to <strong>test them independently from other classes</strong>.</p>
<p>If the Java class <strong>creates an instance of another class via the new operator</strong>, it cannot be used (and tested) independently from this class and this is called a <strong>hard dependency</strong>.</p>
<pre><code class="language-java">public class MyClass {

    private Logger logger;

    public MyClass(Logger logger) {
        this.logger = logger;
        // write an info log message
        logger.info(&quot;This is a log message.&quot;)
    }
}
</code></pre>
<p>Three Types of Dependency Injection</p>
<ol>
<li>Constructor Injection</li>
<li>Setter Injection</li>
<li>Interface Injection</li>
</ol>
<h3 id="user-input">User Input</h3>
<pre><code class="language-java">import java.util.Scanner;  // Import the Scanner class

class MyClass {
  public static void main(String[] args) {
    Scanner myObj = new Scanner(System.in);  // Create a Scanner object
    System.out.println(&quot;Enter username&quot;);

    String userName = myObj.nextLine();  // Read user input
    System.out.println(&quot;Username is: &quot; + userName);  // Output user input
  }
}

</code></pre>
<h3 id="switch-statement">Switch Statement</h3>
<pre><code class="language-java">switch(choice) {
	case 1:
		System.out.println(&quot;You entered a one!&quot;);
		System.out.println(&quot;Thank you!&quot;);
	case 2:
		System.out.println(&quot;You entered a two!&quot;);
		System.out.println(&quot;Amazing!&quot;);
	case 3:
		System.out.println(&quot;You entered a three!&quot;);
		System.out.println(&quot;Good!&quot;);
	default:
		System.out.println(&quot;You entered a number!&quot;);
		System.out.println(&quot;lol!&quot;);
}
</code></pre>
<hr>
<h2 id="the-good-coding-style">The Good Coding Style</h2>
<h3 id="the-one-name-principle">The One Name Principle</h3>
<p>Use the <strong>this</strong> keyword to reference the current object for clarity. Java will do auto dereference when an object is not needed.<br>
Name field and constructor parameters the same.</p>
<h3 id="classes-and-visibility">Classes and Visibility</h3>
<ul>
<li>All <strong>fields</strong> (instance data) are set to <strong>private</strong>. Public methods can call private mothods.</li>
<li>If you want something to be unchangeable, you may provide no setters to prevent invalid data.
<ul>
<li>Easier for maintainance</li>
</ul>
</li>
<li>Using constant when applicable (the <strong>final</strong> keyword, UPPERCASE)
<ul>
<li>Final Variable -&gt; To create constant variables</li>
<li>Final Methods -&gt; Prevent Method Overriding</li>
<li>Final Classes -&gt; Prevent Inheritance</li>
</ul>
</li>
<li>Use the <strong>static</strong> keyword <strong>only when sharing is intended</strong></li>
<li><code>/src/main/java/‚Ä¶</code></li>
<li>Return a string instead of printing it to console directly.</li>
<li>Primitive Types are not objects. Everything else is an object reference.</li>
</ul>
<h3 id="type-conversion">Type Conversion</h3>
<ol>
<li>Type Promotion: Converting from a smaller type to a larger one.<br>
<code>double weight = 200;</code></li>
<li>Type Demotion</li>
</ol>
<pre><code class="language-java">int height = (int) 10.99;
float length = float 12.0; // by default it uses double
</code></pre>
<ol start="3">
<li>Constants<br>
<code>final int MAX_LENGTH = 100;</code></li>
</ol>
<h3 id="javadoc-documentation">JavaDoc (Documentation)</h3>
<pre><code class="language-java">/**
	* @author
	* @param a Length of the first side; must be &gt;= 0. 
	*/
</code></pre>
<p>Use it for classes (the purpose of a class etc.) and sometimes for API methods. Don't comment functions / methods, instead, use better naming.</p>
<h3 id="package-model-view">Package &amp; Model-View</h3>
<ul>
<li>Creat a package: <strong>src / main / java -&gt; new -&gt; Package</strong></li>
<li>Example naming: <code>ca.doordemo.model</code></li>
<li>Package is a group of classes that's related to each other. On top of each class within a package, there will be a statement similar to <code>package ca.doordemo.model</code> claiming that the class belongs to which package.</li>
<li>Do not use any System.out.println() in model to increase reusability. (On some platform System.out.println() has no meaning. )</li>
</ul>
<pre><code class="language-java">import ca.doordemo.model.DoorManager;
import ca.doordemo.ui.DoorTextUI;

public class Main {
	// Create model
	DoorManager manager = new DoorManager();
	
	// Create UI
	DoorTextUI ui = new DoorTextUI(Manager);

	// Launch
	ui.show();
}
</code></pre>
<hr>
<h3 id="others">Others</h3>
<ul>
<li><code>boolean</code>is set to false by default.</li>
<li><strong>?</strong>: Providing constructors will delete the default constructor set up by Java</li>
<li><strong>Concatenating</strong> a string and an instance will automatically call the .toString() method.</li>
<li>Everything in Java is a reference, every class is a subclass of the Object class.</li>
<li>println -&gt; prints with <strong>linefeed</strong></li>
<li>char -&gt; Unicode</li>
<li>boolean has only true or false to prevent the &quot;==&quot; mistyping issues.</li>
<li>Divide by 0.0 -&gt; Infinity</li>
</ul>
<hr>
<h2 id="static-exceptions-debugging">Static, Exceptions &amp; Debugging</h2>
<h3 id="static">Static</h3>
<ul>
<li>Static methods / class methods</li>
<li>Static field / class data
<ul>
<li>Often used for constant <code>public static final int DAYS_WEEK = 7</code></li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class StaticFun {
	public static final int TARGET_NUM_HATS = 10;
	private static int countNumMade = 0;
	private int favNum = 0;

	public static void main(String[] args) {
		changeFavNum(42); // ‚ö†Ô∏è non-static function misused
		displayInfo(); 
		favNum = 10; // ‚ö†Ô∏è non-static field
		countNumMade = 9;
	}
	private void changeFavNum(int i) {
		favNum = TARGET_NUM_HATS + i;
		displayInfo();
	}
	private static void displayInfo() {
		System.out.println(&quot;TARGET_NUM_HATS: &quot; + TARGET_NUM_HATS);
		System.out.println(&quot;countNumMade: &quot; + countNumMade);
		System.out.println(&quot;favNum: &quot; + favNum);
	}
}
</code></pre>
<h3 id="exceptions">Exceptions</h3>
<p>Catch the error so that we don't have to shut down the whole program.</p>
<pre><code class="language-java">import java.util.*; // importing everything

public class sample {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int x = 1;
        
        do{
            try{
                System.out.println(&quot;Enter first num: &quot;);
                int n1 = input.nextInt();
                System.out.println(&quot;Enter second num: &quot;);
                int n2 = input.nextInt();
                int sum = n1 / n2; // where the error might occur
                System.out.println(sum);
                x = 2; // runs successfully only without errors
            } catch (Exception e) { // any error
                System.out.println(&quot;You can't do this. &quot;);
            }
        } while(x == 1);
    }
}
</code></pre>
<p>Another sample:<br>
<code>throw new RuntimeException(&quot;Busted!&quot;)</code><strong>?</strong></p>
<h3 id="tostring">.toString()</h3>
<p>All Java objects have a toString() method since all classes inherit from Object. It returns a String object which used for debugging instead of formatted screen / file output.</p>
<pre><code class="language-java">@Override // To prevent typo
public String toString() {
	return getClass.getName() // returns the name of object
		+ &quot; [daField1 = &quot; + daField1
		+ &quot;, daField2 = &quot; + daField2 + &quot;]&quot;;
}
</code></pre>
<h3 id="pass-by-value">Pass by Value</h3>
<p>Java uses pass by value.</p>
<ul>
<li>Passing a primitive type passes its value.</li>
<li>Passing an object passes (by value) a reference to the object</li>
</ul>
<p>This means:</p>
<ul>
<li>When passed a primitive type, changes inside a method have no effect outside the method.</li>
<li>When passed an object, you can modify its state.</li>
<li>You cannot change which object the passed parameter points to.</li>
</ul>
]]></content>
    </entry>
</feed>