<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jenkinsxu.github.io</id>
    <title>Jenkins&apos; Secret Base</title>
    <updated>2020-01-15T03:11:57.177Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jenkinsxu.github.io"/>
    <link rel="self" href="https://jenkinsxu.github.io/atom.xml"/>
    <subtitle>ｄ(･∀･*)♪ﾟYou found my secret base! 

（更多关于我就在 About 标签中）</subtitle>
    <logo>https://jenkinsxu.github.io/images/avatar.png</logo>
    <icon>https://jenkinsxu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Jenkins&apos; Secret Base</rights>
    <entry>
        <title type="html"><![CDATA[Algorithms - Week 1]]></title>
        <id>https://jenkinsxu.github.io/post/algorithms-week-1</id>
        <link href="https://jenkinsxu.github.io/post/algorithms-week-1">
        </link>
        <updated>2020-01-14T11:11:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="fib">fib()</h1>
<h3 id="the-formula">The formula</h3>
<h3 id="facts">Facts</h3>
<ul>
<li>Grow as fast as 2^n</li>
<li>fib(100) is 21 digits long</li>
<li>In general T(n) = 2^(0.694n)</li>
</ul>
<p><strong>Q: What is the precise value of F100 or F200</strong><br>
A exponential algorithm:</p>
<pre><code class="language-python">func fib(n):
	if n = 0: return 0
	if n = 1: return 1
	return fib(n - 1) + fib(n - 2)
</code></pre>
<h3 id="any-algorithm-implies-3-questions">Any algorithm implies 3 questions</h3>
<ol>
<li>Is it correct?</li>
<li>How much time does it take as a function of input size n?</li>
<li>Can we do better?</li>
</ol>
<ul>
<li>Often, space is an important consideration too.</li>
</ul>
<h3 id="answers">Answers</h3>
<ol>
<li>Yes, by definition</li>
<li>Let T(n) be the # of steps needed to compute fib(n)
<ul>
<li>T(n) ≤ 2 for n ≤ 1</li>
<li>T(n) = T(n-1) + T(n-2) + 3 for n &gt; 1<br>
**Observation:**T(n) ≥ F(n)<br>
<strong>Conclusion:</strong><br>
The running time grows as fast as the fibonacci numbers.<br>
T(n) is exponential in n, so very impractical (except for very small n's)<br>
<strong>Q:</strong> How bad?<br>
<strong>A:</strong><br>
T(200) ≥ F100 ≥ 2^138 elementary computing steps.<br>
With 40 trillion operations per seconds (NEC Earth simulator):</li>
<li>fib(200) taken about 2 ^ 92 seconds</li>
<li>Longer than the remaining life of our sun<br>
Even Moore's Law doesn't help.</li>
<li>Computers get 1.6 times faster every year or twice as fast every 18 months.</li>
<li>fib(n) taken roughly 2^0.694n (or 1.6^n)
<ul>
<li>It takes 1.6 times longer to compute Fn+1 than Fn</li>
<li>If we can compute F100 with this years technology, then we can compute F101 with next year's technology. (One more Fibonacci number per year. )</li>
</ul>
</li>
</ul>
</li>
<li>A polynomial algorithm<br>
<strong>Q:</strong> Why is fib(n) so slow?<br>
<strong>A:</strong>  repeated calls<br>
<strong>More sensible approach:</strong> store intermediate results (a form of dynamic programming)</li>
</ol>
<pre><code class="language-swift">func fib(n) {
	if n = 0 {
		return 0
	}
	f = [0, 1]
	for i in 2...n {
		f.append(f[i-1] + f[i-2])	
	}
	return f[n]
}
</code></pre>
<ul>
<li>Correct by definition</li>
<li>Inner loop gets executed n-1 times (one addition)
<ul>
<li>fib(n) is linear in n</li>
<li>we are now down from exponential to linear time</li>
<li>One outstanding issue: fib(n) has to add increasingly larger integers
<ul>
<li>issues around precision or time</li>
<li>it takes more time to add F199 and F200 than e.g. F3 and F4
<ul>
<li>fib(n) roughly performed Fn additions -&gt; # of basic steps is roughly proportional to n*Fn (still exponential)</li>
</ul>
</li>
</ul>
</li>
<li>
<h1 id="of-basic-steps-is-roughly-proportional-to-n2-still-polynomial-hw-why-bits-level">of basic steps is roughly proportional to <strong>n^2</strong> (still polynomial) <strong>[HW: Why? - bits level]</strong></h1>
</li>
</ul>
</li>
</ul>
<h1 id="the-big-o-notation">The Big-O Notation</h1>
<ul>
<li>
<p>Need to be precise, but not overly detailed</p>
</li>
<li>
<p>Want to be <strong>machine and architecture independant</strong></p>
</li>
<li>
<p>Further simplification</p>
</li>
<li>
<p>can be viewed as the analog of the relation ⊆</p>
</li>
<li>
<p>we can also define the analogs of ≥ and = as follows</p>
<ul>
<li>f = Ω(g) means g = O(f)</li>
<li>f = Θ(g) means f = O(g) and f = Ω(g)</li>
</ul>
</li>
</ul>
<h1 id="algorithms-with-numbers">Algorithms with numbers</h1>
<h2 id="factoring">Factoring</h2>
<p>Express N as product of its prime factors.</p>
<ul>
<li>Factoring is hard. Exponential in he number of bits of N.</li>
</ul>
<h2 id="primality">Primality</h2>
<p>Is N a prime?</p>
<ul>
<li>Primality testing is very easy!</li>
</ul>
<p>As we shall see, the above 2 problems lie at the heart of <strong>secure encrypted communication</strong>.</p>
<p>First things first: Need for algorithms for basic arithmetic.</p>
<h3 id="basic-grade-school-addition">Basic (grade school) addition</h3>
<ul>
<li>Works because the sum of any 3 single digit number is at most 2 digits long (this holds for all bases b ≥ 2)
<ul>
<li>Example:</li>
</ul>
</li>
</ul>
<pre><code>	110101 
+	100011
---------
1 011000
</code></pre>
<p><strong>Q:</strong> How fast is this?<br>
<strong>A:</strong> 2n bit number can be added in n + 1 steps, so about c0 + c1*n ⇒ O(n).<br>
<strong>Q:</strong> Can we do better?<br>
<strong>A:</strong> At the minimum we must read 2 n-bit numbers and write down the answer. Even that requires n steps. ⇒ it is <strong>optimal</strong>. (Up to multiplicative constants c0 and c1)</p>
<h3 id="multiplication">Multiplication</h3>
<ul>
<li>The grade school algorithm</li>
<li>The Al-Khwarizmi Multiplication</li>
</ul>
<pre><code>11*13 table
div2, floor()		*2
11					13
5					26
2					52 (strike out)
1					104
</code></pre>
<pre><code>* strike out all rows where x is even
* then add column 2
</code></pre>
<p><strong>Q:</strong> How does this relate to the binary grade school multiplication algorithm?<br>
<strong>A:</strong> The second algorithm is essentially the same as the binary multiplication. We are adding multiples of 13 by powers of 2 as before.<br>
As before:</p>
<pre><code>2^0 * 13 = 13
2^1 * 13 = 26
2^2 * 13 = 104	∑ = 143
// See text for a third alternative of multiplication
// All 3 versions of multiplication require O(n²) if n = # of bits. 
// We can do better! 
</code></pre>
<h3 id="division">Division</h3>
<p>To divide integer x by integer y ≠ 0 means to fine integer q and r &lt; y such that x = q(quotient) * y + r(remainder)</p>
<ul>
<li>Standard division (see Fig. 1.2. in text) takes quadratic time.</li>
</ul>
<h1 id="modular-arithmetic">Modular Arithmetic</h1>
<p>Modular arithmetic is a system for dealing with restricted ranges of integers.<br>
<code>x modulo N -&gt; remainder when x is divided by N</code><br>
Ex. 	17 modulo 4 = 1<br>
21 modulo 4 = 1<br>
We say that 17 and 21 are congruent modulo 4. Notation:</p>
<pre><code>a ≡ b (mod n)
Clock with 60 minutes: -1 ≡ 59 (mod 60)
</code></pre>
<ul>
<li>Modular arithmetic can be thought of as limiting integers to a specific range of [0, 1, ... , N-1] with &quot;wrap-around&quot;.</li>
<li>Another interpretation is that it deals with all integer, but divides them into N equivalence classes.</li>
</ul>
<pre><code>	...	-9	-6	-3	[0]	3	6	...
{	...	-8	-5	-2	[1]	4	7	...	} 3 equivalent classes mod 3
	...	-7	-4	-1	[2]	5	8	...
</code></pre>
<h3 id="laws-in-modular-arithmetic">Laws in Modular Arithmetic</h3>
<ul>
<li>Substitution Law<br>
If 		x ≡ x' (mod N) and y ≡ y' (mod N)<br>
then:	x + y ≡ x' + y' (mod N) and<br>
x * y ≡ x' * y' (mod N)</li>
<li>Commutative, Associative, Distributive Laws (etc.) also hold (<strong>HW</strong>)</li>
<li>Can do reduction during calcualtion<br>
2^345 ≡ (2<sup>5)</sup>69 ≡ 32^69 ≡ 1^69 ≡ 1	(mod 31)  31 = (2^5 - 1)<br>
(because 31≡ 1 mod 31)</li>
</ul>
<h3 id="addition-mod-n">Addition (mod N)</h3>
<p>x + y (mod N)<br>
x and y are in the range 0 to N-1 ⇒ x + y ∈ [0, ... , 2(N-1)]<br>
if x + y &gt; N-1, simply <strong>subtract N</strong> to reduce mod N<br>
⇒ 1 addition, possibly 1 subtraction of numbers ≤ 2N<br>
⇒ Run time is O(n), where n = ceil(logN) (# of bits)</p>
<h3 id="multiplication-mod-n">Multiplication (mod N)</h3>
<ul>
<li>product is ≤ (N-1)², at most 2n bits -&gt; since log(N-1)² = 2*log(N-1) ≤ 2n
<ul>
<li>regular multiplication: x*y -&gt; O(n²)</li>
<li>reduce mod N</li>
</ul>
</li>
<li>Use division algorithm O(n²) to get the remainder<br>
⇒ O(n²) for modular multiplication</li>
</ul>
<h3 id="division-2">Division</h3>
<ul>
<li>Not quite so straight forward</li>
<li>Can be managed in O(n³) time
<ul>
<li>This is more expensive than regular integer division that was O(n²)</li>
</ul>
</li>
</ul>
<h3 id="modular-exponentiation">Modular Exponentiation</h3>
<p>Goal: Build a crypto-system</p>
<ul>
<li>We need to compute x^y mod N, where x, y and N are several 100 bits long.</li>
<li>x^y is huge even if x and y are only 20-bit numbers.<br>
⇒ x^y is at least (2<sup>19)</sup>(2^19) or about 10,000,000 bits long.</li>
</ul>
<hr>
<p>We could just repeatedly multiply by x modulo y</p>
<pre><code>x		mod N
x²		mod N
x³		mod N
...
x^y	mod N 
</code></pre>
<p>All numbers are &lt; N, but we need to perform y-1 multiplications!<br>
If y has 500 bits ⇒ y - 1 ≈ 2^500 multiplications!<br>
⇒ clearly exponential in the size of y.</p>
<p><strong>Q:</strong> Can we do better?<br>
<strong>A:</strong> Yes! Square repeatedly modulo N</p>
<pre><code>	 x 	mod N 
	 x²	mod N
	 ...
	 x^2^( ceil( log y ) ) mod N
</code></pre>
<ul>
<li>Each takes O(log²N) time
<ul>
<li>numbers are &lt; N</li>
<li>have &lt; logN bits<br>
⇒ now only log y multiplications</li>
</ul>
</li>
<li>Now, we have all x<sup>(2</sup>i)  (1 ≤ i ≤ ceil( log y ) )</li>
<li>To determine x^y mod N proceed as follows:</li>
</ul>
<pre><code>x^25 ≡ x^11001 	≡ x^10000 * x^1000 * x^1
					≡ x^16 * x^8 * x 	mod N (look up in table)
</code></pre>
<hr>
<p><strong>Alternate Formulation</strong><br>
Recursive Algorithm (Fig. 1.4)</p>
<pre><code>x^y
	= (x ^ ceil(y / 2) ) ² if y is even
	= x * (x ^ ( x^(y / 2) ) ) if y is odd
execute this mod N. 
</code></pre>
<ul>
<li>Recursive multiplication used repeated doubling</li>
<li>Recursive exponentiation uses repeated squaring<br>
⇒ n recursive calls (O(n)), multiply n-bit numbers (O(n²))<br>
⇒ O(n³) for modular exponentiation.</li>
</ul>
<h2 id="division-and-mod-n-need-gcd-and-euclids-algorithm">Division and mod N - Need GCD and Euclids Algorithm</h2>
<ul>
<li>gcd(a, b) is the largest integer d that divides both a and b</li>
<li>One approach to compute gcd: factor a and b, then multiply together their common factors:<br>
<strong>Example:</strong></li>
</ul>
<pre><code>1035	= 3² * 5 * 23 
759	= 3 * 11 * 23
Common factors: 3 and 23
⇒ 3 * 32 = 69 is the gcd of 1035 and 759
</code></pre>
<p><strong>But:</strong> Factoring is hard!</p>
<p><strong>Solution:</strong> Euclid's Algorithm<br>
* Based on the following rule: If x and y are positive integers with x ≥ y, then <strong>gcd(x, y)  = gcd(x mod y, y)</strong><br>
<strong>Proof:</strong> Enough to show the simpler rule gcd(x, y)  = gcd(x-y, y).<br>
* Any integer that divides both x and y must also divide x-y, so gcd(x, y) ≤ gcd(x-y, y).<br>
* Likewise, any integer that divides both x-y and y, must  also divide x, so gcd(x-y, y) ≤ gcd(x, y)<br>
⇒ gcd(x, y) = gcd(x-y, y)</p>
<hr>
<p><strong>Euclid's algorithm for finding gcd(a, b)</strong><br>
function Euclid(a, b)<br>
Input: a, b ∈ H+ with a ≥ b ≥ 0<br>
Output: 		gcd(a, b)<br>
if b = 0: return a mod b<br>
Time: After any 2 consecutive rounds, both argument a and b, are the the vast least halved in value, i, e. t their length decreases by at least one bit.<br>
* the base case can be reached within 2n recursive call<br>
* Each call involves O(n²) division<br>
* total time is O(n³)<br>
<strong>HW:</strong> Think about the details. See P.21 for more info.</p>
<hr>
<p><strong>Extension to Euclid's Algorithm</strong><br>
* The gcd(a, b) is the <strong>smallest</strong> positive integer that can be written s a linear combination of a and b.<br>
⇒ d = gcd(a, b) ≡ ax+ by (linear combination) for some integer x and y. (And d must be <strong>minimal</strong>.)</p>
<p>Textbook uses a slightly different approach.<br>
<strong>Q:</strong> What is different?<br>
<strong>A:</strong> We can extend the Euclidian Algorithm to compute the coefficients for the linear combination.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 09 - Introduction to UIKit Part 5]]></title>
        <id>https://jenkinsxu.github.io/post/day-09-introduction-to-uikit-part-5</id>
        <link href="https://jenkinsxu.github.io/post/day-09-introduction-to-uikit-part-5">
        </link>
        <updated>2020-01-14T11:09:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="controls-responding-to-user-input">Controls (Responding to user input)</h2>
<p>When the user interacts with a control, the <strong>control triggers</strong> a <strong>control event</strong>. Different controls trigger different control events.</p>
<p>After setting up a control in Interface Builder, you set up an <strong>IBAction</strong> that responds to a specific control event and allows you to execute a block of code.<br>
Most often you will use the Primary Action Triggered <code>UIControl.Event.primaryActionriggered</code>control event. This control event is triggered when <strong>a button is tapped</strong> or when <strong>the value of a control changes</strong>.</p>
<h3 id="buttons-uibutton">Buttons <code>UIButton</code></h3>
<p><img src="https://jenkinsxu.github.io/post-images/1579057827392.png" alt="" loading="lazy"><br>
The primary control is triggered when</p>
<ul>
<li>the user <strong>releases a button after tapping it</strong></li>
<li>the user <strong>first touches the button</strong></li>
<li>the user <strong>holds down the button</strong></li>
<li>the user cancels the tap by <strong>dragging their finger outside of the frame</strong> of the button before lifting their finger.</li>
</ul>
<h3 id="segmented-controls-uisegmentedcontrol">Segmented Controls <code>UISegmentedControl</code></h3>
<figure data-type="image" tabindex="1"><img src="https://jenkinsxu.github.io/post-images/1579057838404.png" alt="" loading="lazy"></figure>
<ul>
<li>Each segment functions as a discrete button.<br>
<img src="https://jenkinsxu.github.io/post-images/1579057844085.png" alt="" loading="lazy"><br>
Segmented controls execute code when the control’s value changes. The value <strong>represents which segment of the control is selected</strong>.</li>
</ul>
<h3 id="text-fields-uitextfield">Text Fields <code>UITextField</code></h3>
<p>Text fields allow the user to input a <strong>single line</strong> of text into an app.<br>
<img src="https://jenkinsxu.github.io/post-images/1579057852817.png" alt="" loading="lazy"><br>
Text fields execute code when the user <strong>presses the &quot;Return&quot; or &quot;Done&quot;</strong> key on keyboard or when the user <strong>edits the text</strong>.</p>
<h3 id="sliders-uislider">Sliders <code>UISlider</code></h3>
<figure data-type="image" tabindex="2"><img src="https://jenkinsxu.github.io/post-images/1579057860001.png" alt="" loading="lazy"></figure>
<h3 id="switches-uiswitch">Switches <code>UISwitch</code></h3>
<figure data-type="image" tabindex="3"><img src="https://jenkinsxu.github.io/post-images/1579057865815.png" alt="" loading="lazy"></figure>
<h3 id="date-pickers">Date Pickers</h3>
<figure data-type="image" tabindex="4"><img src="https://jenkinsxu.github.io/post-images/1579057871731.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 08 - Introduction to UIKit Part 4]]></title>
        <id>https://jenkinsxu.github.io/post/day-08-introduction-to-uikit-part-4</id>
        <link href="https://jenkinsxu.github.io/post/day-08-introduction-to-uikit-part-4">
        </link>
        <updated>2020-01-04T12:17:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="27-introduction-to-uikit">2.7 Introduction to UIKit</h2>
<ul>
<li>The foundational class for all visual elements defined in UIKit is the <strong>UIView</strong>, or view. A view defines a rectangular shape that can be customized to display anything on the screen. Text, images, lines, and graphics all depend on UIView as the base.</li>
</ul>
<h3 id="special-uiview-subclasses">Special UIView subclasses</h3>
<ul>
<li>UILabel: displays text</li>
<li>UIImageView: displays an image</li>
<li>UIScrollView: allows you to put scrollable content onto the screen</li>
</ul>
<h3 id="a-view-hierarchy">A view hierarchy</h3>
<p><img src="https://jenkinsxu.github.io/post-images/1578255468953.png" alt="" loading="lazy"><br>
Views are often nested. A view that’s contained in another view is called a <strong>child view</strong> (e.g. a cell). A view that contains one or more views is called a <strong>parent view</strong> (e.g. a table view).</p>
<p>To display a view onscreen: give it a frame and add it to the view hierarchy.</p>
<ul>
<li>When adding a view in Interface Builder, its background color is white by default.</li>
<li>When adding a view in code, the background color is transparent by default.</li>
</ul>
<h3 id="attributes-of-views">Attributes of views</h3>
<figure data-type="image" tabindex="1"><img src="https://jenkinsxu.github.io/post-images/1578255479749.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="displaying-information-to-users">Displaying information to users</h2>
<h3 id="label-uilabel">Label (UILabel)</h3>
<p>Labels use <strong>static</strong> text to relay information to the user.<br>
<img src="https://jenkinsxu.github.io/post-images/1578255489380.png" alt="" loading="lazy"></p>
<h3 id="image-view">Image View</h3>
<p>An image view displays an image or an animated sequence of images.<br>
<img src="https://jenkinsxu.github.io/post-images/1578255498395.png" alt="" loading="lazy"></p>
<h3 id="text-view-uitextview">Text View (UITextView)</h3>
<p>A text view allows the user to input text in your app. You’ll typically use a text view to display a large amount of text, such as the body of an email message.<br>
<img src="https://jenkinsxu.github.io/post-images/1578255507711.png" alt="" loading="lazy"></p>
<h3 id="scroll-view-uiscrollview">Scroll View (UIScrollView)</h3>
<p>You’ll typically use a scroll view when the information you want to display is larger than the device’s screen.<br>
<img src="https://jenkinsxu.github.io/post-images/1578255516409.png" alt="" loading="lazy"></p>
<h3 id="table-view-uitableview">Table View (UITableView)</h3>
<p><img src="https://jenkinsxu.github.io/post-images/1578255524295.png" alt="" loading="lazy"><br>
A table view presents data in a single scrollable column of rows and sections, allowing users to navigate easily through groups of information. Table views are an excellent format for displaying and editing <strong>hierarchical lists of information</strong>.<br>
<img src="https://jenkinsxu.github.io/post-images/1578255531409.png" alt="" loading="lazy"></p>
<h3 id="toolbars-uitoolbar">Toolbars (UIToolbar)</h3>
<p>A toolbar usually appears at the bottom of a screen and displays one or more buttons, called <strong>bar button items</strong>.<br>
<img src="https://jenkinsxu.github.io/post-images/1578255539123.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="2"><img src="https://jenkinsxu.github.io/post-images/1578255545038.png" alt="" loading="lazy"></figure>
<h3 id="navigation-bars-uinavigationbar">Navigation Bars (UINavigationBar)</h3>
<p><img src="https://jenkinsxu.github.io/post-images/1578255553420.png" alt="" loading="lazy"><br>
<img src="https://jenkinsxu.github.io/post-images/1578255559223.png" alt="" loading="lazy"></p>
<h3 id="tab-bars-uitabbar">Tab Bars (UITabBar)</h3>
<p>A tab bar provides easy access to different views in an app. The most common way to use a tab bar is with a <strong>tab bar controller</strong>, which holds a property of each view controller that represents each scene you want presented in the tab bar. You’ll add <strong>scenes</strong> to be displayed to the controller, and the tab bar view, you link it to the tab bar controller's viewControllers property in a storyboard (<strong>?</strong>). The view controller for each scene has a <strong>UITabBarItem</strong> property that <strong>defines the text and optional image that will be displayed by the tab bar</strong>.</p>
<hr>
<h2 id="responding-to-user-input">Responding to user input</h2>
<p>unfinished</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 07 - Introduction to UIKit Part 3]]></title>
        <id>https://jenkinsxu.github.io/post/day-07-introduction-to-uikit-part-3</id>
        <link href="https://jenkinsxu.github.io/post/day-07-introduction-to-uikit-part-3">
        </link>
        <updated>2020-01-04T06:49:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="25-collections">2.5 Collections</h2>
<h3 id="arrays">Arrays</h3>
<pre><code class="language-swift">var names: [String] = [&quot;Anne&quot;, &quot;Gary&quot;, &quot;Keith&quot;]
var numbers: [Int8] = [1, -3, 50, 72, -95] // [-127, 128]
</code></pre>
<pre><code class="language-swift">var names = [&quot;Anne&quot;, &quot;Gary&quot;, &quot;Keith&quot;]
let numbers = [1, -3, 50, 72, -95] 

// Check if a certain value exist in an array. 
if numbers.contains(5) {
	print(&quot;There is a 5&quot;)
}
</code></pre>
<h3 id="initialization-of-empty-arrays">Initialization of empty arrays</h3>
<pre><code class="language-swift">var myArray: [Int] = []
</code></pre>
<pre><code class="language-swift">var myArray: Array&lt;Int&gt; = []
</code></pre>
<pre><code class="language-swift">// All objects can be initialized by adding a () after the type name. 
var myArray = [Int]()
</code></pre>
<h3 id="repeating-elements">Repeating elements</h3>
<pre><code class="language-swift">var myArray = [Int](repeating: 0, count: 100) // An array filled with 100 zeros. 
</code></pre>
<h3 id="the-count-and-isempty-properties">The .count and .isEmpty properties</h3>
<ul>
<li>.count: The number of items within an array.</li>
<li>.isEmpty: Check if the array is empty.</li>
</ul>
<h3 id="the-subscript-syntax">The subscript Syntax</h3>
<ul>
<li>zero-indexed</li>
</ul>
<pre><code class="language-swift">names[0]
</code></pre>
<h3 id="adding-and-removing-elements">Adding and removing elements</h3>
<pre><code class="language-swift">var names = [&quot;Amy&quot;]
names.append(&quot;Joe&quot;)
names += [&quot;Keith&quot;, &quot;Jane&quot;] // Adding multiple elements at a time
names.insert(&quot;Bob&quot;, at: 0)

let chelsea = names.remove(at: 2)
let dan = names.removeLast()
names.removeAll()

var myNewArray = firstArray + secondArray
</code></pre>
<hr>
<h3 id="dictionary">Dictionary</h3>
<pre><code class="language-swift">var myDictionary = [String: Int]()

var myDictionary = Dictionary&lt;String, Int&gt;()

var myDictionary: [String: Int] = [:]
</code></pre>
<h3 id="addremovemodify-a-dictionary">Add/Remove/Modify a dictionary</h3>
<pre><code class="language-swift">numberOfLegs[&quot;snake&quot;] = 0

// If there was no value, oldValue will be nil.
let oldValue = scores.updateValue(100, forKey: &quot;Richard&quot;)

// Run code only if a value is returned from the method.
if let oldValue = scores.updateValue(100, forKey: &quot;Richard&quot;) {
	print(&quot;Richard’s old value was \(oldValue)&quot;)
}

// To remove an item from a dictionary, you can use subscript syntax, setting the value to nil. 
// If you need the old value returned before removing it: 
if let oldValue = scores.removeValue(forKey: &quot;&quot;Luke) {
	print(&quot;Luke’s score was \(oldValue) before he stopped playing&quot;)
}
</code></pre>
<h3 id="accessing-a-dictionary">Accessing a dictionary</h3>
<pre><code class="language-swift">let players = Array(scores.keys)
let points = Array(scores.values)

// Execute when exists
if let myScore = scores[&quot;Luke&quot;] {
	print(myScore)
}
</code></pre>
<h2 id="26-loops">2.6 Loops</h2>
<h3 id="for-in-loop">for-in Loop</h3>
<pre><code class="language-swift">for _ 1…3 {
	print(&quot;Hello!&quot;)
}

names = [&quot;Joseph&quot;, &quot;Cathy&quot;, &quot;Winston&quot;]
for name in names {
	print(&quot;Hello, \(name)&quot;)
}

for letter in &quot;ABCD&quot; {
	print(&quot;The letter is \(letter)&quot;)
}

// If you need the index of each element in addition to its value, you can use the enumerated() method (to return a tuple containing both the index and the value of each item)
for (index, letter) in &quot;ABCD&quot;.enumerated() {
	print(&quot;\(index): \(letter)&quot;)
}

let vehicles = [&quot;unicycle&quot;: 1, &quot;bicycle&quot;: 2, &quot;tricycle&quot;: 3, &quot;quad bike&quot;: 4]
for (vehicleName, wheelCount) in vehicles {
	print(&quot;A \(vehicleName) has \(wheelCount) wheels&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 06 - Introduction to UIKit Part 2]]></title>
        <id>https://jenkinsxu.github.io/post/day-06-introduction-to-uikit-part-2</id>
        <link href="https://jenkinsxu.github.io/post/day-06-introduction-to-uikit-part-2">
        </link>
        <updated>2020-01-02T10:32:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="24-classes-inheritance">2.4 Classes, Inheritance</h2>
<ul>
<li>As a basic rule, you should start new types as structures until you need one of the features that classes provide.</li>
<li>Start with a class when you’re working with a framework (ex. <strong>Foundation</strong> or <strong>UIKit</strong>) that uses classes (since many of them have method calls that expect certain things to be classes) or you want to refer to the same instance of a type in multiple places. (<strong>Reference</strong>)</li>
</ul>
<h3 id="create-a-subclass-and-override-methods-and-properties">Create a Subclass and Override Methods and Properties</h3>
<pre><code class="language-swift">class Vehicle {
	var currentSpeed = 0.0

	var description: String {
		return “traveling at \(currentSpeed) miles per hour”
	}

	func makeNoise() {
		
	}
}

class Train: Vehicle {
	override func makeNoise() {
		print(“Choo Choo!”)
	}
}

// You can also override properties by providing a getter, or a block of code that returns the value, like a computed property

// Accesses the description from the superclass by calling super.description

class Car: Vehicle {
	var gear = 1
	override var description: String {
		return super.description + “ in gear \(gear)”
	}
}
</code></pre>
<h3 id="override-initializer">Override Initializer</h3>
<pre><code class="language-swift">class Person {
	let name: String 

	// Swift does not create a member wise initializer for classes. 
	init(name: String) {
		self.name = name
	}
}

class Student: Person {
	var favoriteSubject: String
	
	init(name: String, favoriteSubject: String) {
		self.favoriteSubject = favoriteSubject
		super.init(name: name)
	}
}
</code></pre>
<h3 id="references">References</h3>
<p>Constants or variables that are assigned to an instance store that instance’s address to refer to the instance. So the constant or variable does not contain the value itself, it points to the value in memory. We say the data has a <strong>stable identity</strong>. Updating them as parameter will also update their values.</p>
<pre><code class="language-swift">class Person {
	let name: String
	var age: Int

	init(name: String, age: Int) {
		self.name = name
		self.age = age
	}
}
var jack = Person(name: “Jack”, age: 24)
var myFriend = jack

jack.age += 1

print(jack.age == myFriend.age) // true

// In contrast, when you create an instance of a structure, you’re assigning a literal value to that variable instead of an address. If you create a variable that's equal to another structure variable, the value is copied. 

struct Person {
	var name: String
	var age: Int
}

var jack = Person(name: ”Jack”, age: 24)
var myFriend = jack

jack.age += 1

print(jack.age == myFriend.age) // false
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 05 - Introduction to UIKit Part 2 ]]></title>
        <id>https://jenkinsxu.github.io/post/day-05-introduction-to-uikit-part-2</id>
        <link href="https://jenkinsxu.github.io/post/day-05-introduction-to-uikit-part-2">
        </link>
        <updated>2020-01-02T02:23:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="22-functions">2.2 Functions</h2>
<ul>
<li>A function in Swift can return zero, one or <strong>multiple values</strong>.</li>
</ul>
<h3 id="defining-a-function">Defining a Function</h3>
<pre><code class="language-swift">func functionName (argumentLabel: TypeOfParameter) -&gt; ReturnType {
	//body of the function
}

functionName (parameters: value) //calling the function
</code></pre>
<h3 id="argument-labels-and-local-names">Argument Labels and Local Names</h3>
<pre><code class="language-swift">// specify an external name before the local one
func sayHello(to person: String, and anotherPerson: String) {
	print(“Hello \(person), and \(anotherPerson)”)
}

sayHello(to: “Miles”, and: “Riley”)
</code></pre>
<h3 id="omitting-the-argument-label">Omitting the Argument Label</h3>
<pre><code class="language-swift">func sayHello(_ person: String, _anotherPerson: String) {
	print(“Hello” \(person) and \(anotherPerson))
}

sayHello(“Miles”, “Riley”)
</code></pre>
<h3 id="default-parameter-values">Default Parameter Values</h3>
<p>You’ll need to place all parameters with default values <strong>at the end of the list</strong>, and these parameters must <strong>all have argument labels</strong>.</p>
<pre><code class="language-swift">func display(teamName: String, score: Int = 0) {
	print(“\”(teamName): \(score))
}

display(teamName: “Wombats”, score: 100) //“Wombats: 100”
display(teamName: “Wombats”) //“Wombats: 0”
</code></pre>
<h2 id="23-structures">2.3 Structures</h2>
<ul>
<li>As a general rule, you should use let whenever possible to define an instance of a structure, and use var when defining the properties of a structure (easier for creating new instance from the current ones).</li>
</ul>
<h3 id="default-initializer">Default Initializer</h3>
<pre><code class="language-swift">var string = String.init() // “”
var integer = Int.init() // 0
var bool = Bool.init() // false

// Shorthand version
string = String()
integer = Int()
bool = Bool()
</code></pre>
<h3 id="different-approaches-to-initializing-property-values">Different Approaches to Initializing Property Values</h3>
<ol>
<li><strong>Default Values</strong></li>
</ol>
<pre><code class="language-swift">struct Odometer {
	var count: Int = 0
}
</code></pre>
<ol start="2">
<li><strong>Member-wise Initializer</strong><br>
Member-wise initializers are the correct approach when there’s not a default state for new instance of your type.</li>
</ol>
<pre><code class="language-swift">struct Person {
	var name: String
}

let person = Person(name: “Michelle”) // Member-wise initializer
</code></pre>
<ol start="3">
<li><strong>Custom Initializers</strong><br>
For the times when you want to define an initializer that completes some custom logic before assigning all of the properties.<br>
Custom initializers have the same requirement as default and member-wise initializers: All properties must be set to initial values before completing initialization.</li>
</ol>
<pre><code class="language-swift">struct Temperature {
	var celsius: Double
	
	init(celsius: Double) {
		self.celsius = celsius
	}

	// When you add a custom initializer to a type definition, you must define your own member-wise initializer; Swift no longer provides one for you. 

	init(fahrenheit: Double) {
		celsius = (fahrenheit - 32) / 1.8
	}
}

let boiling = Temperature(fahrenheit: 212.0)
</code></pre>
<h3 id="mutating-methods">Mutating Methods</h3>
<p>Occasionally you’ll want to update the property values of a structure within an instance method. To do so you’ll need to add the mutating keyword.</p>
<pre><code class="language-swift">struct Odometer {
	var count: Int = 0

	mutating func increment() {
		count += 1
	}

	mutating func increment(by amount: Int) {
		count += amount
	}
}
</code></pre>
<h3 id="computed-properties">Computed Properties</h3>
<p>With computed properties, you can create properties that can compute their value based on other instance properties or logic. You must also explicitly declare the type.</p>
<pre><code class="language-swift">struct Temperature {
	var celsius: Double

	var fahrenheit: Double {
		return celsius * 1.8 + 32
	}

	var kelvin: Double {
		return celsius + 273.15
	
}

// The logic contained in a computed property will be executed each time the property is accessed, so the returned value will always bt up to date. 
</code></pre>
<h3 id="property-observers">Property Observers</h3>
<p>Property observers are called every time a property’s value is set.<br>
There are two observer closures, or blocks of code, that you can define on any given property: willSet, and didSet.<br>
Whenever the variable is modified, <strong>willSet will be called first</strong>, and you’ll have access to the new value that will be set to the property value in a constant named <strong>newValue</strong>.<br>
After the property’s value has been updated, <strong>didSe</strong>t will be called, and you can access the previous property value using <strong>oldValue</strong>.</p>
<pre><code class="language-swift">struct StepCounter {
	var totalSteps: Int = 0 {
		willSet {
			print(“About to set totalSteps to \(newValue)”)
		}
		didSet {
			if totalStep &gt; oldStep {
				print(“Added \(totalSteps - OldValue) steps”)
			}
		}
	}
}
</code></pre>
<h3 id="type-properties-and-methods-different-from-instance-methods">Type Properties and Methods (Different from Instance Methods)</h3>
<p>Type properties are useful when a property is related to the type, but not a characteristic of an instance itself.</p>
<pre><code class="language-swift">struct Temperature {
	static var boilingPoint = 100
}

let boilingPoint = Temperature.boilingPoint
</code></pre>
<p>The Double structure, defined in the Swift Standard Library, contains a static method called minimum that returns the smaller of its two parameters.</p>
<pre><code class="language-swift">let smallerNumber = Double.minimum(100.0, -1000.0)
</code></pre>
<h3 id="deep-copying">(Deep) Copying</h3>
<p>If you assign a structure to a variable or pass an instance as a parameter into a function, the values are copied. (Changing one value doesn’t change the other. )</p>
<h3 id="self">Self</h3>
<p>In Swift, <strong>self</strong> refers to the <strong>current instance</strong> of the object.</p>
<pre><code class="language-swift">self.color
</code></pre>
<p>The Swift compiler recognizes when property or method names exist on the current object, and makes using self optional.<br>
The use of self is required within initializers that have parameter names that match property names (<strong>shadowing</strong>).</p>
<pre><code class="language-swift">struct Temperature {
	var celsius: Double
	init(celsius: Double) {
		self.celsius = celsius
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 04 - Introduction to UIKit Part 1]]></title>
        <id>https://jenkinsxu.github.io/post/day-04-introduction-to-uikit-part-1</id>
        <link href="https://jenkinsxu.github.io/post/day-04-introduction-to-uikit-part-1">
        </link>
        <updated>2019-12-31T17:56:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="21-strings">2.1 Strings</h2>
<h3 id="string-literals">String Literals</h3>
<pre><code class="language-swift">&quot;Hello Michelle!&quot;
</code></pre>
<p>If your string literal needs to be multiple lines, simply surround your set of characters with three double quotation marks &quot;&quot;&quot;</p>
<pre><code class="language-swift">let joke = &quot;&quot;&quot;
    Q: why did the chicken cross the road?
    A: To get to the other side! 
    &quot;&quot;&quot;
</code></pre>
<p>Escape character</p>
<pre><code class="language-swift">let greeting = &quot;It is traditional in programming to print \&quot;Hello, world\&quot;&quot;
</code></pre>
<ul>
<li>Double quote <strong>&quot;</strong></li>
<li>Single quote **' **</li>
<li>Backslash <strong>\</strong></li>
<li>Tap <strong>\t</strong></li>
<li>Carriage return <strong>\r</strong></li>
</ul>
<h3 id="check-if-a-swift-string-is-empty-using-the-boolean-property">Check if a Swift String is empty using the Boolean <strong>property</strong></h3>
<pre><code class="language-swift">var myString = &quot;&quot;
if myString.isEmpty {
    print(&quot;The string is empty&quot;)
}
</code></pre>
<h3 id="concatenation-kənˌkætəˈneɪʃn">Concatenation [kənˌkætəˈneɪʃn]</h3>
<pre><code class="language-swift">let myString = string1 + string2
</code></pre>
<h3 id="string-interpolation-ɪnˌtɜːrpəˈleɪʃn">String Interpolation [ɪnˌtɜːrpəˈleɪʃn]</h3>
<pre><code class="language-swift">print(&quot;If a is \(a) and b is \(b), then a + b equals \(a+b)&quot;) 
</code></pre>
<h3 id="useful-methods-of-the-string-type">Useful methods of the String type</h3>
<ul>
<li>.lowercased()</li>
<li>.hasPrefix(_😃</li>
</ul>
<pre><code class="language-swift">let gretting = &quot;Hello, world!&quot;
gretting.hasPrefix(&quot;Hello&quot;)
</code></pre>
<ul>
<li>.hasSuffix(_😃</li>
<li>.contains(_😃</li>
<li>.index(before: ) //Returns the position immediately before the given index.</li>
<li>.index(after: )</li>
<li>index(_:offsetBy:)</li>
</ul>
<pre><code class="language-swift">let s = &quot;Swift&quot;
let i = s.index(s.startIndex, offsetBy: 4)
print(s[i])
// Prints &quot;t&quot;
</code></pre>
<ul>
<li>insert(contentsOf:at:)</li>
<li>remove(at:)</li>
<li>removeSubrange(_😃</li>
<li>replaceSubrange(_:, with:)</li>
</ul>
<h3 id="useful-properties-of-the-string-type">Useful properties of the String type</h3>
<ul>
<li>.count</li>
<li>.startIndex //The position of the first character in a nonempty string.</li>
<li>.endIndex</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 03 - Getting Started with App Development Part 3]]></title>
        <id>https://jenkinsxu.github.io/post/day-03-getting-started-with-app-development-part-3</id>
        <link href="https://jenkinsxu.github.io/post/day-03-getting-started-with-app-development-part-3">
        </link>
        <updated>2019-12-28T19:25:02.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Swift booleans have a method, **toggle() **</li>
<li>Command-Shift-L to view library</li>
</ul>
<h3 id="setting-background-color">Setting background color</h3>
<pre><code class="language-swift">view.backgroundColor = .white
</code></pre>
<ul>
<li>UIControl.State represents the different potential states of a button (a data type?)</li>
</ul>
<h3 id="a-normal-button">A &quot;normal&quot; button</h3>
<pre><code class="language-swift">static var normal: UIControl.State //Define a normal constant corresponding to the state of the button when it's enabled and sitting idle on the screen
</code></pre>
<h3 id="changing-a-title">Changing a title</h3>
<pre><code class="language-swift">lightButton.setTitle(&quot;Off&quot;, for: .normal)
</code></pre>
<h3 id="clear-out-unused-outlets-with-connection-panel">Clear out unused outlets with connection panel</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 02 - Getting Started with App Development Part 2]]></title>
        <id>https://jenkinsxu.github.io/post/day-02-getting-started-with-app-development</id>
        <link href="https://jenkinsxu.github.io/post/day-02-getting-started-with-app-development">
        </link>
        <updated>2019-12-27T06:48:55.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Assistant editor <img src="https://jenkinsxu.github.io/post-images/1577775101967.png" alt="" loading="lazy"> - to view the storyboard and the definition at the same time.</li>
<li>The <strong>Custom Class</strong> is set to be ViewConrtoller by default. But the ViewController class <strong>still doesn’t have access</strong> to the button you added. To make the object <strong>accessible in code</strong>, you’ll need to <strong>create an outlet</strong>.</li>
</ul>
<h3 id="outlets-and-actions">Outlets and Actions</h3>
<ul>
<li>Outlets - reference <strong>visual elements</strong> from Interface Builder to code
<ul>
<li><strong>Creating Outlet</strong>: <strong>Right-click and drag</strong> toward the assistant editor pane, which contains the ViewController class definition. Connection is set to <strong>Outlet</strong> and Storage is set to <strong>Strong</strong>. In the name field, specify a variable name for the button: “myButton”.</li>
</ul>
</li>
</ul>
<pre><code class="language-swift">import UIKit

class ViewController: UIViewController {
</code></pre>
<pre><code class="language-swift">⚫️	@IBOutlet var myButton: UIButton!
//Circle - The filled circle indicates that the outlet is connected. 
//@IBOutlet - Unique to Interface Builder, this keyword specifies a relationship between the variable and a storyboard. Without the @IBOutlet keyword, the circle doesn’t display. 
//: UIButton! - The type of the property is a UIButton, the button type within the UIKit framework (import UIKit). The exclamation point warns you that the program will crash if you try to access this property *and* the outlet isn’t connected. 
</code></pre>
<pre><code class="language-swift">		override func viewDidLoad() { // gives you access to the view controller's main view property before it is displayed on the screen - good for setting up
			super.viewDidLoad()
			// Do any additional setup after loading the view
			myButton.setTitleColor(.red, for: .normal) //changes the color of the button
		}
</code></pre>
<ul>
<li>Actions - a reference to <strong>a piece of code that will execute when the interaction takes place</strong>
<ul>
<li>Connection is set to <strong>Action</strong></li>
</ul>
</li>
</ul>
<pre><code class="language-swift">⚫️	@IBAction func buttonPressed(_ sender: Any) {

		}
//Circle - The filled circle indicates that the action is connected. 
//@IBOutlet - Unique to Interface Builder, this keyword specifies a relationship between an action and an object in a storyboard. 
//(_ sender: Any) - An action can be connected to a number of different objects: buttons, sliders, switches, etc. In this example, sender is the name of the *object* that triggers the action. Because sender could represent any of several user interface elements, it’s of the Any type. 
</code></pre>
<h3 id="companion-property">Companion property</h3>
<p><img src="https://jenkinsxu.github.io/post-images/1577775126509.png" alt="" loading="lazy"><br>
Many objects that you can configure in Interface Builder have properties that can only be set programmatically.<br>
* Do so programmatically by setting up an IBOutlet and updating the properties using dot notation.</p>
<pre><code class="language-swift">scrollView.contentSize = CGSize(width: 100, height: 100)
</code></pre>
<h3 id="setting-up-all-child-views-and-adding-them-to-the-screen">Setting up all child views and adding them to the screen</h3>
<pre><code class="language-swift">let label = UILabel(frame: CGRect(x: 16, y: 16, width: 200, height: 44))
view.addSubview(label) // Adds label as a child view to 'view'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 01 - Getting Started with App Development Part 1]]></title>
        <id>https://jenkinsxu.github.io/post/day-01-getting-started-with-app-development-part-1</id>
        <link href="https://jenkinsxu.github.io/post/day-01-getting-started-with-app-development-part-1">
        </link>
        <updated>2019-12-25T20:17:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="12-constants-variables-and-data-types">1.2 Constants, variables and data types</h2>
<ul>
<li>Type <strong>:quit</strong> and press Enter to exit the <strong>Swift REPL</strong>.</li>
<li>One of type inference or type annotation must be done when creating a variable / constant.</li>
<li>Use <strong>option click</strong> to check data types</li>
</ul>
<h3 id="type-inference">Type Inference</h3>
<pre><code class="language-swift">let name = “John” //names can’t begin with a number
</code></pre>
<h3 id="type-definition">Type Definition</h3>
<pre><code class="language-swift">struct Person { //The first letter needs to be capitalized
	//two properties
	let firstName:String //Type annotation
	let lastName :String

	func sayHello() {
		print(“Hello there! My name is \(firstName) \(lastName).”)
	}
}

//creating an instance
let aPerson = Person(firstName: “Jacob”, lastName: ”Edwards”)
</code></pre>
<h3 id="increasing-readability-of-long-numbers">Increasing readability of long numbers</h3>
<pre><code class="language-swift">largePrettyNumber = 1_000_000_000
</code></pre>
<h2 id="13-operators">1.3 Operators</h2>
<ul>
<li>When you use the division operator <strong>/</strong> on <strong>Int values</strong>, the result will be an Int value <strong>rounded down</strong> to the nearest whole number. (Only the integer property got stored.)</li>
</ul>
<h3 id="creating-a-new-value-of-other-types-by-prefixing">Creating a <em>new</em> value of other types by prefixing</h3>
<pre><code class="language-swift">let pi = Double(3) + 0.1415927
</code></pre>
<h3 id="referencing-the-current-variable"><em>Referencing</em> the current variable</h3>
<pre><code class="language-swift">myScore += 3 //compound assignment operators
</code></pre>
<h2 id="14-control-flow">1.4 Control Flow</h2>
<ul>
<li>closed interval: 1.2…5.0</li>
<li>open interval: 1.2..&lt;5.0</li>
</ul>
<h3 id="coding-style-in-if-else-statements">Coding style in if-else statements</h3>
<pre><code class="language-swift">let temperature = 100
if temperature &gt;= 100 { //no brackets needed here
	print(“The water is boiling.”)
} else { //write it in the same line
	print(“”The water is not boiling. )
}
</code></pre>
<h3 id="switch-statement">Switch statement</h3>
<pre><code class="language-swift">let character = “z”
switch character {
	case “a”, “e”, “i”, “o”, “u”:
		print(“This character is a vowel.”)
	//provide a default case
	default:
		print(“This character is not a vowel.”) 
}

let distance = 100
switch distance {
	case 0…9: //inclusive
		print(“Your destination is close.”)
	case 10…99:
		print(“Your destination is medium distance from here.”)
	case 100…999:
		print(“Your destination is far from here.”)
	//provide a default case
	default:
		print(“Are you sure you want to travel this far?”) 
}
</code></pre>
<h2 id="15-xcode">1.5 Xcode</h2>
<ul>
<li>All <strong>.storyboard</strong> files are unique to <strong>Interface Builder</strong>. They contain information about the design of each <strong>scene</strong> within your application.</li>
<li>The <strong>.xcassets</strong> file makes it easy to <strong>maintain all your assets</strong>, without needing to work with individual icons and images.</li>
<li>The <strong>Info.plist</strong> file contains a list of <strong>properties and settings</strong> for your app.</li>
</ul>
<h3 id="xcode-interface">Xcode Interface</h3>
<figure data-type="image" tabindex="1"><img src="https://jenkinsxu.github.io/post-images/1577660369776.png" alt="" loading="lazy"></figure>
<h3 id="deployment-info">Deployment Info</h3>
<p><img src="https://jenkinsxu.github.io/post-images/1577660391882.png" alt="" loading="lazy"><br>
The entry in Main Interface defines which storyboard file will be loaded first when the app launches.</p>
<h2 id="16-building-running-and-debugging-an-app">1.6 Building, Running, and Debugging an App</h2>
<ul>
<li>To <strong>rotate the image</strong> from portrait to landscape orientation, use the keyboard shortcuts <strong>Command-Left</strong> and <strong>Command-Right</strong>.</li>
<li>You can use keyboard shortcuts, from <strong>Command-1 to Command-3</strong>, to <strong>scale the device image</strong> up or down.</li>
<li>If you try to use Simulator to test an interaction with the Camera app, the program will crash.</li>
<li>The MessageUI framework is incompatible with Simulator.</li>
</ul>
<h3 id="scheme-menu">Scheme menu</h3>
<figure data-type="image" tabindex="2"><img src="https://jenkinsxu.github.io/post-images/1577660405930.png" alt="" loading="lazy"></figure>
<h3 id="types-of-issue">Types of issue</h3>
<ol>
<li>Warnings ⚠️</li>
<li>Compiler Errors ❌</li>
<li>Bugs</li>
</ol>
<h3 id="using-breakpoints-and-step-controls">Using breakpoints and step controls</h3>
<p><img src="https://jenkinsxu.github.io/post-images/1577660418345.png" alt="" loading="lazy"><br>
Since the breakpointed line hasn’t yet been executed, names contains no values. (Not inclusive.)</p>
<figure data-type="image" tabindex="3"><img src="https://jenkinsxu.github.io/post-images/1577660427843.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>Continue</strong> - Resumes code execution <strong>until the next breakpoint is reached</strong>.</li>
<li><strong>Step over</strong> - Executes the selected line and pauses execution <strong>on the next line.</strong></li>
<li><strong>Step into</strong> - If clicked on a line with a function call, advances <strong>to the first line of the function</strong>, then pauses execution again.</li>
<li><strong>Step out</strong> - Executes all remaining lines in the function call and pauses execution <strong>on the line after the function</strong>.</li>
</ul>
<h2 id="17-documentation">1.7 Documentation</h2>
<ul>
<li>Documentation call a view that’s embedded in another view <strong>subviews</strong>.</li>
<li>Documentation call the parent view that’s embedding the other view <strong>superviews</strong>.</li>
<li>The <strong>frame</strong> property defines the origin and dimensions of the view in the coordinate system of its superview.</li>
<li>The <strong>bounds</strong> property defines the internal dimensions of the view as it sees them and is used almost <strong>exclusively in custom drawing code</strong>.</li>
</ul>
<h3 id="three-of-the-primary-responsibilities-of-a-uiview-object">Three of the primary responsibilities of a UIView object</h3>
<ul>
<li>Drawing and animation</li>
<li>Layout and subview management</li>
<li>Event handling</li>
</ul>
<h3 id="the-quick-help-feature">The Quick Help Feature</h3>
<p><img src="https://jenkinsxu.github.io/post-images/1577660441907.png" alt="" loading="lazy"><br>
<strong>Option-click</strong> a method name, then Xcode will displays a popover with a brief description of the function and the OS versions that support it.</p>
<h3 id="xcode-help">Xcode Help</h3>
<p><img src="https://jenkinsxu.github.io/post-images/1577660451173.png" alt="" loading="lazy"><br>
<strong>Command-Shift-O</strong></p>
<h2 id="interface-builder-basics">Interface Builder Basics</h2>
<ul>
<li>Interface Builder opens whenever you select an <strong>.xib</strong> file or a <strong>.storyboard</strong> file from the project navigator.</li>
<li>An XIB file contains t user interface for a single visual element, such as a full-screen view a table view cell or a custom UI control.</li>
<li>A storyboard file includes many pieces of the interface, defining the layout of <strong>one or many screens</strong> as well as <strong>the progression from one screen to another</strong>.</li>
<li>The single scene with a plain white view on an otherwise blank canvas is called the <strong>initial view controller</strong>.  (Can be changed by moving the <strong>entry point</strong>.)</li>
<li>Select the Library button <img src="https://jenkinsxu.github.io/post-images/1577660466003.png" alt="" loading="lazy"> in the toolbar to display the Object Library.</li>
</ul>
<h3 id="document-outline-view">Document Outline View</h3>
<figure data-type="image" tabindex="4"><img src="https://jenkinsxu.github.io/post-images/1577660475918.png" alt="" loading="lazy"></figure>
<h3 id="context-sensitive-inspectors">Context-sensitive Inspectors</h3>
<ul>
<li>The <strong>Identity inspector</strong> <img src="https://jenkinsxu.github.io/post-images/1577660488900.png" alt="" loading="lazy"> allows you to edit the <strong>properties related to an object’s identity</strong>, such as what class it belongs to.</li>
<li>The <strong>Attributes inspector</strong> <img src="https://jenkinsxu.github.io/post-images/1577660499132.png" alt="" loading="lazy"> provides a list of <strong>adjustable visual properties</strong> for the selected item.</li>
<li>The <strong>Size inspector</strong>  <img src="https://jenkinsxu.github.io/post-images/1577660509414.png" alt="" loading="lazy"> allows you to adjust the <strong>size and position</strong> of the selected element within the scene. You will use the X and Y fields - where the <strong>top left</strong> of the screen corresponds to (0, 0) - to change the position.</li>
<li>The <strong>Connections inspector</strong> <img src="https://jenkinsxu.github.io/post-images/1577660519829.png" alt="" loading="lazy"> lists <strong>all the functions and variable names related to the object</strong>.</li>
</ul>
]]></content>
    </entry>
</feed>